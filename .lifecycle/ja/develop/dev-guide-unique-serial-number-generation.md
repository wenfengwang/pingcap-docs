---
title: ユニークシリアル番号の生成
summary: 独自のユニークIDを生成する開発者向けのユニークシリアル番号生成ソリューション。

# ユニークシリアル番号の生成

このドキュメントは、独自のユニークIDを生成する開発者向けに、ユニークなシリアル番号生成スキームを紹介します。

## 自動増分列

`AUTO_INCREMENT` は、MySQLプロトコルと互換性のある多くのRDBMSのカラム属性です。 `AUTO_INCREMENT` 属性を使用すると、データベースはユーザーの介入なしにこの列に値を自動的に割り当てることができます。 テーブル内のレコード数が増加すると、この列の値は自動的に増分し、一意であることが保証されます。 ほとんどのシナリオでは、`AUTO_INCREMENT` 列は実際の意味を持たないプロキシ主キーとして使用されます。

`AUTO_INCREMENT` 列の制限は、列が整数型である必要があり、それに割り当てられる値も整数である必要があります。 アプリケーションで必要とされるシリアル番号が、文字、数字、および他の文字でスライスされる場合、`AUTO_INCREMENT` 列を介して必要な自動増分番号を取得することは難しいです。

## シーケンス

**シーケンス**は、アプリケーションがインクリメンタルなシーケンス値を生成するために呼び出すことができるデータベースオブジェクトです。 アプリケーションは、シーケンス値を柔軟に使用して1つ以上のテーブルに値を割り当てることができます。 アプリケーションは、シーケンス値を使用してテキストと数字の組み合わせを生成するより複雑な処理にも利用することができます。 このアプローチにより、プロキシキーに追跡と分類の意味が与えられます。

シーケンスは、TiDB v4.0から利用可能です。 詳細については、[シーケンスのドキュメント](/sql-statements/sql-statement-create-sequence.md#create-sequence) を参照してください。

## Snowflakeライクのソリューション

Snowflakeは、Twitterが提案した分散ID生成ソリューションです。 Baiduの**uid-generator** やMeituanの**leaf** など、いくつかの実装があります。 一般的なものとしては、`uid-generator` の実装があります。

`uid-generator` が生成する64ビットのID構造は次のとおりです:

```
| sign | delta seconds | worker node id | sequence |
|------|---------------|----------------|----------|
| 1ビット |     28ビット    | 22ビット         | 13ビット   |
```

- sign: 固定長の1ビット。 常に正の数であることを示すために `0` に固定されます。
- delta seconds: デフォルトでは28ビット。 プリセットされた基準時刻（デフォルトは `2016-05-20`）との間の増分値として表される現在の時間。 28ビットでは約8.7年までサポートされます。
- worker node id: デフォルトでは22ビット。 マシンID を表し、通常はアプリケーションプロセスの開始時に集中型ID生成器から取得されます。 一般的な中央集権型ID生成器には、自動増分列やZooKeeperが含まれます。 デフォルトの割り当てポリシーは、「捨てて進む」 であり、プロセスは再起動時に新しいワーカーノードIDを再取得します。 22ビットでは約420万の起動までサポートされます。
- sequence: デフォルトでは13ビット。 秒間の同時実行シーケンス。 13ビットでは1秒あたり8192の同時シーケンスをサポートします。

## 数値割り当てソリューション

数値割り当てソリューションは、データベースから自動増分IDをまとめて取得すると理解できます。 このスキームでは、シーケンス番号生成テーブルが必要で、各行がシーケンスオブジェクトを表します。 テーブル定義の例は次のとおりです:

| フィールド名 | フィールドタイプ | フィールドの説明 |
| -------- | ------------ | ---------------------------- |
| `SEQ_NAME` | varchar(128) | シーケンスの名前、異なるアプリケーションを区別するために使用されます。 |
| `MAX_ID` | bigint(20) | 現在割り当てられているシーケンスの最大値。 |
| `STEP` | int(11) | 割り当てられるセグメントの長さを示すステップ。 |

アプリケーションは、毎回、設定されたステップでシーケンス番号のセグメントを取得します。 同時に、アプリケーションはデータベースを更新して、現在割り当てられているシーケンスの最大値を永続化します。 シーケンス番号の処理と割り当てはアプリケーションのメモリで完了します。 シーケンス番号のセグメントを使い切ると、アプリケーションは新しいセグメントのシーケンス番号を取得し、効果的にデータベース書き込みの圧力を和らげます。 実践では、ステップを調整してデータベース更新の頻度を制御することもできます。

最後に、上記2つのソリューションによって生成されたIDは、TiDBのテーブルの **主キー** として直接使用するには十分にランダムではありません。 実践では、生成されたIDに対してビットリバース処理を行い、よりランダムな新しいIDを取得することができます。