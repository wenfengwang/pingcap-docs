---
title: 暗黙の型変換の回避
summary: TiDBにおける暗黙の型変換の可能な影響とその回避方法を紹介します。
---

# 暗黙の型変換の回避

このドキュメントでは、TiDBにおける暗黙の型変換のルールとその可能な影響、および暗黙の型変換を回避する方法について紹介します。

## 変換のルール

SQL文の述部におけるデータ型が一致しない場合、TiDBは述部の操作に互換性のあるデータ型へ一方もしくは双方のデータ型を暗黙的に変換します。

TiDBにおける暗黙の型変換のルールは次のとおりです:

- 一方もしくは両方の引数が`NULL`の場合、比較の結果は`NULL`です。`NULL`セーフな`<=>`同等比較演算子は変換を必要としません。なぜならば、NULL `<=>` NULL は`true`になるからです。
- 比較操作において両方の引数が文字列の場合、文字列として比較されます。
- 両方の引数が整数の場合、整数として比較されます。
- 数値との比較が行われていない場合、16進数値はバイナリ文字列として扱われます。
- 一方の引数が10進数値の場合、比較は他の引数に依存します。他の引数が10進数値もしくは整数値の場合、引数は10進数値と比較されます。他の引数が浮動小数点数値の場合、引数は浮動小数点数値と比較されます。
- 一方の引数が`TIMESTAMP`もしくは`DATETIME`列で、他の引数が定数の場合、比較が行われる前に定数はタイムスタンプに変換されます。
- その他の全ての場合において、引数は浮動小数点数値（`DOUBLE`型）として比較されます。

## 暗黙の型変換による影響

暗黙の型変換により、人間とコンピュータの相互作用の利便性が向上します。ただし、アプリケーションコードにおいて暗黙の型変換を使用することは避けてください。なぜならば、以下の問題を引き起こす可能性があるからです:

- インデックスの無効化
- 精度の損失

### インデックスの無効化

以下の場合において、`account_id`はプライマリキーであり、そのデータ型は`varchar`です。このSQL文には暗黙の型変換が含まれており、実行計画においてインデックスを使用することができません。

```sql
DESC SELECT * FROM `account` WHERE `account_id`=6010000000009801;
+-------------------------+----------------+-----------+---------------+------------------------------------------------------------+
| id                      | estRows        | task      | access object | operator info                                              |
+-------------------------+----------------+-----------+---------------+------------------------------------------------------------+
| TableReader_7           | 8000628000.00  | root      |               | data:Selection_6                                           |
| └─Selection_6           | 8000628000.00  | cop[tikv] |               | eq(cast(findpt.account.account_id), 6.010000000009801e+15) |
|   └─TableFullScan_5     | 10000785000.00 | cop[tikv] | table:account | keep order:false                                           |
+-------------------------+----------------+-----------+---------------+------------------------------------------------------------+
3 rows in set (0.00 sec)
```

**実行結果の概要**: 上記の実行計画から、`Cast`演算子が見えます。

### 精度の損失

以下の場合において、`a`フィールドのデータ型は`decimal(32,0)`です。このSQL文に暗黙の型変換が発生し、10進フィールドと文字列定数が共に倍精度浮動小数点数型に変換されます。倍精度浮動小数点数型の精度は10進数よりも高くないため、精度の損失が発生します。この場合、SQL文は結果セットを誤って範囲外にフィルタリングします。

```sql
DESC SELECT * FROM `t1` WHERE `a` BETWEEN '12123123' AND '1111222211111111200000';
+-------------------------+---------+-----------+---------------+-------------------------------------------------------------------------------------+
| id                      | estRows | task      | access object | operator info                                                                       |
+-------------------------+---------+-----------+---------------+-------------------------------------------------------------------------------------+
| TableReader_7           | 0.80    | root      |               | data:Selection_6                                                                    |
| └─Selection_6           | 0.80    | cop[tikv] |               | ge(cast(findpt.t1.a), 1.2123123e+07), le(cast(findpt.t1.a), 1.1112222111111112e+21) |
|   └─TableFullScan_5     | 1.00    | cop[tikv] | table:t1      | keep order:false, stats:pseudo                                                      |
+-------------------------+---------+-----------+---------------+-------------------------------------------------------------------------------------+
3 rows in set (0.00 sec)
```

**実行結果の概要**: 上記の実行計画から、`Cast`演算子が見えます。

```sql
SELECT * FROM `t1` WHERE `a` BETWEEN '12123123' AND '1111222211111111200000';
+------------------------+
| a                      |
+------------------------+
| 1111222211111111222211 |
+------------------------+
1 row in set (0.01 sec)

```

**実行結果の概要**: 上記の実行は誤った結果を返します。