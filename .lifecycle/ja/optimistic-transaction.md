---
title: TiDB楽観的トランザクションモデル
summary: TiDBにおける楽観的トランザクションモデルについて学ぶ
aliases: ['/docs/dev/optimistic-transaction/','/docs/dev/reference/transactions/transaction-optimistic/','/docs/dev/reference/transactions/transaction-model/']
---

# TiDB楽観的トランザクションモデル

楽観的トランザクションでは、競合する変更はトランザクションのコミットの一部として検出されます。これにより、並行トランザクションがまれに同じ行を変更する場合、行のロックを取得するプロセスをスキップできるため、パフォーマンスが向上します。ただし、並行トランザクションが頻繁に同じ行を変更する場合（競合）、楽観的トランザクションは[Pessimistic Transactions](/pessimistic-transaction.md)よりも性能が悪くなる場合があります。

楽観的トランザクションを有効にする前に、`COMMIT`ステートメントがエラーを返す可能性があることをアプリケーションが正しく処理していることを確認してください。これについての確信が持てない場合は、代わりにPessimistic Transactionsを使用することをお勧めします。

> **注意:**
>
> v3.0.8から、TiDBはデフォルトで[pessimistic transaction mode](/pessimistic-transaction.md)を使用します。ただし、v3.0.8以上にアップグレードする既存のクラスターには影響がありません。要するに、**デフォルトで悲観的トランザクションモードを使用するのは新しく作成されたクラスターのみ**です。

## 楽観的トランザクションの原則

分散トランザクションをサポートするため、TiDBでは楽観的トランザクションで二相コミット（2PC）を採用しています。手順は次のとおりです:

![TiDBにおける2PC](/media/2pc-in-tidb.png)

1. クライアントがトランザクションを開始します。

    TiDBはPDからタイムスタンプ（時間的に単調に増加し、グローバルに一意のもの）を取得し、現在のトランザクションのユニークなトランザクションIDである`start_ts`として使用します。TiDBはマルチバージョン並行制御を実装しているため、`start_ts`はこのトランザクションによって取得されたデータベーススナップショットのバージョンとしても機能します。つまり、トランザクションは`start_ts`でのみデータベースからデータを読むことができます。

2. クライアントが読み取りリクエストを発行します。

    1. TiDBはPDからルーティング情報（データがTiKVノード間で分散されている方法）を受け取ります。
    2. TiDBはTiKVから`start_ts`バージョンのデータを受け取ります。

3. クライアントが書き込みリクエストを発行します。

    TiDBは書き込まれたデータが制約を満たしているかどうかをチェックします（データ型が正しいか、NOT NULL制約が満たされているか）。**有効なデータはTiDBのこのトランザクションのプライベートメモリに保存されます**。

4. クライアントがコミットリクエストを発行します。

5. TiDBは2PCを開始し、トランザクションの原子性を保証しながらストアにデータを永続化します。

    1. TiDBは書き込むデータからプライマリキーを選択します。
    2. TiDBはPDからリージョン分布の情報を受け取り、すべてのキーをそれに応じてリージョンごとにグループ化します。
    3. TiDBは関与するすべてのTiKVノードに対して事前書き込みリクエストを送信します。その後、TiKVは競合や期限切れのバージョンが存在するかどうかをチェックします。有効なデータはロックされます。
    4. TiDBは事前書き込みフェーズでのすべての応答を受け取り、事前書き込みが成功です。
    5. TiDBはPDからコミットバージョン番号を受け取り、それを`commit_ts`としてマークします。
    6. TiDBはプライマリキーのあるTiKVノードに対して2番目のコミットを開始します。TiKVはデータをチェックし、事前書き込みフェーズで残ったロックをクリアします。
    7. TiDBは第2段階が正常に完了したことを報告するメッセージを受け取ります。

6. TiDBはトランザクションが正常にコミットされたことを通知するメッセージを返します。

7. TiDBはこのトランザクションで残ったロックを非同期でクリーンアップします。

## 利点と欠点

上記のTiDBトランザクションの手順から分かるように、TiDBトランザクションには以下の利点があります:

* 理解しやすい
* 単一行トランザクションに基づいたクロスノードトランザクションの実装
* 分散ロック管理

ただし、TiDBトランザクションには以下のような欠点もあります:

* 2PCによるトランザクションのレイテンシ
* 中央集権的なタイムスタンプの割り当てサービスが必要
* 大量のデータをメモリに書き込んだ場合のメモリ不足（OOM）

## トランザクションのリトライ

楽観的トランザクションモデルでは、トランザクションがヘビーな競合シナリオにおいて書き込み-書き込み競合によりコミットに失敗する可能性があります。TiDBはデフォルトで楽観的並行制御を使用しますが、MySQLは悲観的並行制御を適用します。これは、MySQLが書き込み型SQLステートメントの実行中にロックを追加し、そのRepeatable Read分離レベルによって現在の読み取りが可能になるため、通常はコミットが例外に遭遇しません。アプリケーションの適応性を下げるために、TiDBは内部のリトライメカニズムを提供します。

### 自動リトライ

トランザクションのコミット中に書き込み-書き込み競合が発生した場合、TiDBは自動的に書き込み操作を含むSQLステートメントをリトライします。自動リトライを有効にするには、`tidb_disable_txn_auto_retry`を`OFF`に設定し、`tidb_retry_limit`を設定してリトライ制限を設定できます:

```toml
# 自動リトライを無効にするかどうか。 (デフォルトは "on"）
tidb_disable_txn_auto_retry = OFF
# リトライの最大回数を設定します。 (デフォルトは "10"）
# "tidb_retry_limit = 0"の場合、自動リトライは完全に無効になります。
tidb_retry_limit = 10
```

自動リトライをセッションレベルまたはグローバルレベルで有効にすることができます:

1. セッションレベル:

    {{< copyable "sql" >}}

    ```sql
    SET tidb_disable_txn_auto_retry = OFF;
    ```

    {{< copyable "sql" >}}

    ```sql
    SET tidb_retry_limit = 10;
    ```

2. グローバルレベル:

    {{< copyable "sql" >}}

    ```sql
    SET GLOBAL tidb_disable_txn_auto_retry = OFF;
    ```

    {{< copyable "sql" >}}

    ```sql
    SET GLOBAL tidb_retry_limit = 10;
    ```

> **注意:**
>
> `tidb_retry_limit`変数はリトライの最大回数を決定します。この変数を`0`に設定すると、暗黙的な単一ステートメントトランザクションを含むすべてのトランザクションが自動的にリトライされなくなります。これはTiDBの自動リトライメカニズムを完全に無効化する方法です。自動リトライが無効になった後、すべての競合トランザクションは（`後でやり直してください`のメッセージを含む）最速の方法でアプリケーションレイヤーに失敗を報告します。

### リトライの制限

デフォルトでは、TiDBはリトライしないので、これにより失われた更新と[`REPEATABLE READ`隔離](/transaction-isolation-levels.md)の損傷を招く可能性があります。

リトライ手順からその理由は次のとおりです:

1. 新しいタイムスタンプを割り当て、`start_ts`としてマークします。
2. 書き込み操作を含むSQLステートメントをリトライします。
3. 2相コミットを実行します。

Step2で、TiDBは書き込み操作を含むSQLステートメントのみをリトライします。ただし、リトライ中にTiDBは新しい`start_ts`バージョンでデータを受け取ります。このため、トランザクションが他のクエリ結果を使用してデータを更新する場合、`REPEATABLE READ`隔離が違反される可能性があるため、結果は一貫性がない可能性があります。

アプリケーションが失われた更新を許容し、`REPEATABLE READ`隔離の一貫性を要求しない場合は、`tidb_disable_txn_auto_retry = OFF`と設定することでこの機能を有効にできます。

## 競合検出

分散データベースとして、TiDBでは競合検出は主にTiKVレイヤーでメモリ内で行われます。TiDBインスタンスは状態を持たず、互いに無関係であるため、クラスタ全体での書き込みが競合するかどうかはわかりません。したがって、競合検出はTiKVレイヤーで実行されます。

構成は次のとおりです:

```toml
# スロットの数を制御します。 (デフォルトは "2048000"）
scheduler-concurrency = 2048000
```

また、TiKVはスケジューラで待機中のラッチに費やした時間を監視することもサポートしています。

![スケジューララッチの待機時間](/media/optimistic-transaction-metric.png)

`スケジューララッチの待機時間`が長い場合かつ遅い書き込みがない場合、その時間に多くの書き込み競合があることが安全に結論付けられます。