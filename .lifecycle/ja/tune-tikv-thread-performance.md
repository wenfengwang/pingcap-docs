---
title: TiKVスレッドプールのパフォーマンスチューニング
summary: TiKVスレッドプールの最適なパフォーマンスをチューニングする方法について学びます。
aliases: ['/docs/dev/tune-tikv-thread-performance/']
---

# TiKVスレッドプールのパフォーマンスチューニング

このドキュメントでは、TiKVの内部スレッドプールとそのパフォーマンスチューニング方法について紹介します。

## スレッドプールの概要

TiKVスレッドプールは、主にgRPC、スケジューラ、UnifyReadPool、Raftstore、StoreWriter、Apply、RocksDB、およびCPUをあまり消費しない一部のスケジュールされたタスクと検出コンポーネントから構成されています。このドキュメントでは、読み書きリクエストのパフォーマンスに影響を与えるいくつかのCPU集約型スレッドプールについて主に紹介します。

* gRPCスレッドプール: すべてのネットワークリクエストを処理し、異なるタスクタイプのリクエストを異なるスレッドプールに振り分けます。

* スケジューラスレッドプール: 書き込みトランザクションの競合を検出し、2段階コミット、悲観的ロック、トランザクションのロールバックなどのリクエストをキー値ペアの配列に変換し、それをRaftstoreスレッドにRaftログ複製のため送ります。

* Raftstoreスレッドプール:

	- すべてのRaftメッセージと新しいログの追加提案を処理します。
	- Raftログをディスクに書き込みます。[`store-io-pool-size`](/tikv-configuration-file.md#store-io-pool-size-new-in-v530)の値が`0`の場合、Raftstoreスレッドはログをディスクに書き込みます。`0`でない場合、RaftstoreスレッドはログをStoreWriterスレッドに送信します。
	- 大多数のレプリカのRaftログが一致した場合、RaftstoreスレッドはログをApplyスレッドに送信します。

* StoreWriterスレッドプール: すべてのRaftログをディスクに書き込み、その結果をRaftstoreスレッドに返します。

* Applyスレッドプール: Raftstoreスレッドプールから送信された提出ログを受け取り、それをキー値リクエストとして解析し、RocksDBに書き込み、書き込みリクエストが完了したことをgRPCスレッドプールに通知するコールバック関数を呼び出し、その結果をクライアントに返します。

* RocksDBスレッドプール: RocksDBのコンパクションおよびフラッシュタスクのためのスレッドプールです。RocksDBのアーキテクチャおよび`Compact`操作については、[RocksDB: A Persistent Key-Value Store for Flash and RAM Storage](https://github.com/facebook/rocksdb)を参照してください。

* UnifyReadPoolスレッドプール: CoprocessorスレッドプールとStorage Read Poolの組み合わせです。kv get、kv batch get、raw kv get、およびcoprocessorなどのすべての読み取りリクエストは、このスレッドプールで実行されます。

## TiKVの読み取り専用リクエスト

TiKVの読み取りリクエストには以下のタイプがあります:

- 特定の行または複数の行を指定する単純なクエリは、Storage Read Poolで実行されます。
- 複雑な集計計算および範囲クエリは、Coprocessor Read Poolで実行されます。

TiKV v5.0から、すべての読み取りリクエストはデフォルトで統一スレッドプールを使用しています。TiKVクラスタがTiKV v4.0からアップグレードされ、アップグレード前に`readpool.storage`の`use-unified-pool`設定が`false`に設定されていた場合、アップグレード後もすべての読み取りリクエストは異なるスレッドプールを使用し続けます。この場合、すべての読み取りリクエストを統一スレッドプールで処理するために、`readpool.storage.use-unified-pool`の値を`true`に設定することができます。

## TiKVスレッドプールのパフォーマンスチューニング

* gRPCスレッドプール

    gRPCスレッドプールのデフォルトサイズ（`server.grpc-concurrency`で構成）は`5`です。このスレッドプールにはほとんど計算オーバーヘッドがなく、主にネットワークI/Oと逆シリアル化リクエストを担当しているため、通常はデフォルト設定を調整する必要はありません。

    - TiKVをデプロイしたマシンのCPUコア数が少ない（8以下）場合は、`server.grpc-concurrency`構成項目を`2`に設定することを検討してください。
    - TiKVをデプロイしたマシンが非常に高い構成であり、多数の読み書きリクエストを処理する場合、`server.grpc-concurrency`の値が`TiKV-Details.Thread CPU`のGrafanaでの監視値が`80% * server.grpc-concurrency`以下になるように`server.grpc-concurrency`の値を増やすことを検討してください。

* スケジューラスレッドプール

    TiKVがマシンのCPUコア数が16以上であることを検出した場合、スケジューラスレッドプールのデフォルトサイズ（`storage.scheduler-worker-pool-size`で構成）は`8`です。CPUコア数が16未満の場合は、デフォルトサイズは`4`です。

    このスレッドプールは、主に複雑なトランザクションリクエストを単純なキー値読み書きリクエストに変換するために使用されます。しかし、**スケジューラスレッドプールは自体では書き込み操作を行いません**。

    - トランザクションの競合が検出された場合、このスレッドプールは事前にクライアントに競合結果を返します。
    - 競合が検出されない場合、このスレッドプールは書き込み操作を行うキー値リクエストをRaftログにマージし、Raftstoreスレッドに送信します。

    一般的に、過剰なスレッド切り替えを避けるために、スケジューラスレッドプールの使用率を50%から75%の間に保つことが最適です。スレッドプールサイズが`8`の場合は、`TiKV-Details.Thread CPU.scheduler worker CPU`をGrafanaで400%から600%の間に保つことをお勧めします。

* Raftstoreスレッドプール

    RaftstoreスレッドプールはTiKVで最も複雑なスレッドプールです。このスレッドプールのデフォルトサイズ（`raftstore.store-pool-size`で構成）は`2`です。ストアライタースレッドプールのデフォルトサイズ（`raftstore.store-io-pool-size`で構成）は`0`です。

    - ストアライタースレッドプールのサイズが0の場合、すべての書き込みリクエストはRaftstoreスレッドによって`fsync`方式でRocksDBに書き込まれます。この場合、パフォーマンスを以下のようにチューニングすることをお勧めします:

        - Raftstoreスレッドの全体のCPU使用率を60%以下に保つこと。Raftstoreスレッドの数が2の場合、Grafanaでの**TiKV-Details**、**Thread CPU**、**Raft store CPU**を120%以下に保つこと。I/Oリクエストにより、理論上はRaftstoreスレッドのCPU使用率は常に100%未満です。
        - 慎重な検討なしに書き込みパフォーマンスを向上させるためにRaftstoreスレッドプールのサイズを増やさないでください。これによりディスクの負荷が増加し、パフォーマンスが低下する可能性があります。

    - ストアライタースレッドプールのサイズが0でない場合、すべての書き込みリクエストはストアライタースレッドによって`fsync`方式でRocksDBに書き込まれます。この場合、パフォーマンスを以下のようにチューニングすることをお勧めします:

        - ストアライタースレッドプールが有効になっている場合は、全体のCPUリソースが十分であることを確認してください。ストアライタースレッドプールを有効にした場合は、ストアライタースレッドとRaftstoreスレッドのCPU使用率を80%以下に保ってください。

         Raftstoreスレッドが書き込みリクエストを処理する場合と比較して、ストアライタースレッドが書き込みリクエストを処理する場合、理論的には書き込み遅延とデータ読み取りのテールレイテンシが大幅に低下します。ただし、書き込み速度が速くなるにつれて、Raftログの数がそれに応じて増加します。これにより、Raftstoreスレッド、Applyスレッド、gRPCスレッドのCPU負荷が増加する可能性があります。この場合、不十分なCPUリソースはチューニング効果を相殺し、結果として書き込み速度が以前より遅くなる可能性があります。そのため、CPUリソースが十分でない場合は、ストアライタースレッドを有効にすることは推奨されません。Raftstoreスレッドは大部分のI/Oリクエストをストアライタースレッドに送信するため、RaftstoreスレッドのCPU使用率を80%以下に保つ必要があります。

    - ほとんどの場合、ストアライタースレッドプールのサイズを1または2に設定します。ストアライタースレッドプールのサイズはRaftログの数に影響するため、スレッドプールのサイズの値はあまり大きくしないようにする必要があります。CPU使用率が80%を超える場合、スレッドプールのサイズを増やすことを検討してください。

    - Raftログの増加が他のスレッドプールのCPU負荷に与える影響に注意してください。必要に応じて、Raftstoreスレッド、Applyスレッド、およびgRPCスレッドの数を増やす必要があります。

* UnifyReadPoolスレッドプール

    UnifyReadPoolはすべての読み取りリクエストを処理します。デフォルトのサイズ（`readpool.unified.max-thread-count`で構成）は、マシンのCPUコア数の80%です。たとえば、マシンCPUが16コアの場合、デフォルトのスレッドプールサイズは12です。アプリケーションのワークロードに応じてCPU使用率を調整し、スレッドプールサイズの60%から90%の間に保つことをお勧めします。

    もしGrafanaでの`TiKV-Details.Thread CPU.Unified read pool CPU`のピーク値が800%を超えない場合、`readpool.unified.max-thread-count`を`10`に設定することをお勧めします。スレッドが多すぎると、スレッドの切り替えが頻繁に起こり、他のスレッドプールのリソースを消費します。
```markdown
    + {T}
    + {T}
      + {T}
        + {T}
          + {T}
          + {T}
      + {T}
        + {T}
          + {T}
              + {T}
              + {T}
              + {T}
          + {T}
          + {T}
```