---
title: タイタンの概要
summary: タイタンストレージエンジンの概要を学びます。

# タイタンの概要

[Titan](https://github.com/pingcap/rocksdb/tree/titan-5.15) は、高性能の [RocksDB](https://github.com/facebook/rocksdb) プラグインであり、キーと値を分離するためのものです。タイタンは、RocksDBで大きな値が使用される場合に、書き込みの拡大を軽減することができます。

キーと値のサイズが大きい場合（1 KB以上または512 B）、タイタンは、RocksDBよりも書き込み、更新、およびポイント読み取りシナリオで優れたパフォーマンスを発揮します。ただし、タイタンはストレージ容量および範囲クエリのパフォーマンスを犠牲にして、より高い書き込みパフォーマンスを得ています。SSDの価格が下がり続けることで、このトレードオフはさらに有意義になるでしょう。

## キー機能

- ログ構造マージツリー（LSMツリー）から値を分離し、書き込みの膨大化を軽減します。
- RocksDBのインスタンスを簡単にタイタンにアップグレードできます。アップグレードには人間の干渉が不要で、オンラインサービスに影響を与えません。
- 現在のTiKVで使用されるすべてのRocksDB機能と100%の互換性を実現します。

## 使用シナリオ

タイタンは、大量のデータがTiKVの前面に書き込まれるシナリオに適しています:

- RocksDBが多数のコンパクションをトリガーし、多くのI/O帯域幅またはCPUリソースを消費します。これにより前面の読み書きパフォーマンスが低下します。
- RocksDBのコンパクションが（I/O帯域幅の制限またはCPUのボトルネックにより）大幅に遅れ、書き込みの停滞を頻繁に引き起こします。
- RocksDBが多数のコンパクションをトリガーし、多くのI/O書き込みを引き起こし、SSDディスクの寿命に影響を与えます。

## 前提条件

タイタンを有効にするための前提条件は以下の通りです:

- 値の平均サイズが大きいか、大きな値のサイズが総値の大部分を占めていること。現在、1 KBより大きな値のサイズは大きな値と見なされます。状況によっては、この数値（1 KB）は512 Bになることがあります。なお、TiKVに書き込まれる単一の値のサイズは、TiKV Raftレイヤーの制限により8 MBを超えることはできません。この制限を緩和するために、[`raft-entry-max-size`](/tikv-configuration-file.md#raft-entry-max-size) 構成値を調整できます。
- 範囲クエリが行われないか、範囲クエリの高いパフォーマンスが必要ではないこと。なぜなら、タイタンに格納されているデータは整列されていないため、範囲クエリのパフォーマンスはRocksDBに比べて劣っています。特に大きな範囲のクエリに関しては、PingCAP社内テストによると、タイタンの範囲クエリパフォーマンスはRocksDBの40%から数倍低いとされています。
- 十分なディスク容量（同じデータ量でRocksDBのディスク消費量の2倍を確保することを検討してください）。なぜなら、タイタンはストレージスペースを節約する代わりに書き込みの膨大化を軽減しています。また、タイタンは値を1つずつ圧縮し、その圧縮率はRocksDBよりも低くなっています。RocksDBはブロックを1つずつ圧縮します。そのため、タイタンはRocksDBよりも多くのストレージスペースを消費しますが、これは期待される正常な動作です。状況によっては、タイタンのストレージ消費量はRocksDBの2倍になることがあります。

タイタンのパフォーマンスを向上させたい場合は、ブログ記事[Titan: A RocksDB Plugin to Reduce Write Amplification](https://pingcap.com/blog/titan-storage-engine-design-and-implementation/)をご覧ください。

## アーキテクチャと実装

以下の図は、タイタンのアーキテクチャを示しています:

![タイタンのアーキテクチャ](/media/titan/titan-1.png)

フラッシュおよびコンパクション操作中、タイタンはLSMツリーから値を分離します。このアプローチの利点は、書き込みプロセスがRocksDBと一貫しているため、RocksDBへの侵入的な変更の可能性が低くなることです。

### BlobFile

タイタンが値ファイルをLSMツリーから分離すると、値ファイルはBlobFileに保存されます。以下の図はBlobFileの形式を示しています:

![BlobFileの形式](/media/titan/titan-2.png)

blobファイルは主にblobレコード、メタブロック、メタインデックスブロック、およびフッタで構成されています。それぞれのブロックレコードはキーと値のペアを保存します。メタブロックは拡張性のために使用され、blobファイルに関連するプロパティを保存します。メタインデックスブロックはメタブロックの検索に使用されます。

> **注意:**
>
> + blobファイル内のキーと値のペアは順番に保存されるため、Iteratorが実装されている場合、シーケンシャルな読み取りパフォーマンスがプリフェッチにより向上します。
> + 各blobレコードは、値に対応するユーザーキーのコピーを保持しています。これにより、タイタンがGarbage Collection（GC）を実行する際にユーザーキーをクエリし、対応する値が古くなっているかどうかを識別できます。ただし、このプロセスは一定の書き込みの拡大を導入します。
> + BlobFileはblobレコードレベルでの圧縮をサポートしています。タイタンは[Snappy](https://github.com/google/snappy)、[LZ4](https://github.com/lz4/lz4)、および[Zstd](https://github.com/facebook/zstd)などの複数の圧縮アルゴリズムをサポートしています。現在、タイタンがデフォルトで使用している圧縮アルゴリズムはLZ4です。
> + Snappy圧縮ファイルは[公式のSnappyフォーマット](https://github.com/google/snappy)である必要があります。他のバリエーションのSnappy圧縮はサポートされていません。

### TitanTableBuilder

![TitanTableBuilder](/media/titan/titan-3.png)

TitanTableBuilderは、キーと値を分離するための鍵となります。TitanTableBuilderは、キーペアの値サイズを決定し、それに基づいて値を分離してblobファイルに保存するかどうかを決定します。

+ 値のサイズが`min_blob_size`以上の場合、TitanTableBuilderは値を分離し、blobファイルに保存します。同時に、TitanTableBuilderはインデックスを生成し、SSTに書き込みます。
+ 値のサイズが`min_blob_size`より小さい場合、TitanTableBuilderは値を直接SSTに書き込みます。

上記のプロセスで、TitanはRocksDBにダウングレードすることもできます。RocksDBがコンパクションを実行している際、分離された値は新しく生成されたSSTファイルに書き戻すことができます。

## Garbage Collection

タイタンは、ゴミ収集（GC）を使用して空き領域を回収します。LSMツリーコンパクション中にキーが回収されるため、blobファイルに保存されている一部の値は同時に削除されません。したがって、タイタンは定期的にGCを実行し、古い値を削除する必要があります。タイタンは次の2つのタイプのGCを提供します:

+ 定期的にblobファイルを統合し、古い値を削除して書き直します。これが通常のGCの方法です。
+ LSMツリーコンパクションの実行中にblobファイルを書き直します。これがLevel Mergeの機能です。

### 通常のGC

タイタンは、RocksDBのTablePropertiesCollectorとEventListenerコンポーネントを使用してGCのための情報を収集します。

#### TablePropertiesCollector

RocksDBは、BlobFileSizeCollectorというカスタムテーブルプロパティコレクターを使用してSSTからプロパティを収集できます。収集されたプロパティはBlobFileSizePropertiesと呼ばれます。以下の図は、BlobFileSizeCollectorのワークフローとデータ形式を示しています:

![BlobFileSizeProperties](/media/titan/titan-4.png)

左側はSSTインデックスの形式です。第1列はblobファイルID、第2列はblobファイル内のblobレコードのオフセット、第3列はblobレコードのサイズです。

右側はBlobFileSizePropertiesの形式です。各行はblobファイルと、このblobファイルに保存されたデータのサイズを表します。第1列はblobファイルID、第2列はデータのサイズです。

#### EventListener

RocksDBは、古いデータを破棄し、空き領域を再利用するためにコンパクションを使用します。各コンパクション後に、Titanのblobファイルには古くなったデータが部分的または完全に含まれる可能性があります。したがって、コンパクションイベントをリッスンしてGCをトリガーすることができます。コンパクション中に、入力/出力のblobファイルサイズプロパティを収集し、これらを比較して、GCが必要なblobファイルを特定できます。以下の図は一般的なプロセスを示しています:

![EventListener](/media/titan/titan-5.png)

+ *inputs* は、コンパクションに参加するすべてのSSTのblobファイルサイズプロパティを表します。
+ *outputs* は、コンパクションで生成されたすべてのSSTのblobファイルサイズプロパティを表します。
+ *discardable size* は、入力と出力に基づいて計算した各blobファイルの破棄可能なサイズを表します。第1列はblobファイルID、第2列は破棄するファイルのサイズです。

各有効なblobファイルに対して、Titanはメモリ内で破棄可能なサイズ変数を維持します。各コンパクション後に、この変数は対応するblobファイルに積み上げられます。GC開始時に、破棄可能なファイルのサイズが特定の比率に到達した場合にのみ、GCを開始できるようにするため、一定レベルの空間の膨張が許可されます。選択されたblobファイルについて、Titanは、各値に対応するキーのblobインデックスが存在するか、または更新されているかをチェックし、その値が古くなっているかどうかを確認します。選択されたblobファイルの場合、Titanは値を新しいblobファイルにマージおよび並べ替えし、更新されたblobインデックスをWriteCallbackまたはMergeOperatorを使用してSSTに書き込みます。その後、TitanはRocksDBの最新のシーケンス番号を記録し、古いblobファイルを削除しません。古いblobインデックスに以前のスナップショット経由でアクセスできる可能性があるため、GCが対応するblobファイルを安全に削除できるまで、最も古いスナップショットのシーケンスが記録されたシーケンス番号を超えないようにする必要があります。これは、blobインデックスがSSTに戻された後も、以前のスナップショットを介して古いblobインデックスにアクセスできるためです。したがって、GCが安全に対応するblobファイルを削除する前に、古いblobインデックスにスナップショットがアクセスしないことを確認する必要があります。

### Level Merge
```
      + {T}
      + {T}
    + {T}
  + {T}
```