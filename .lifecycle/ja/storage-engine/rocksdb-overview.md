---
title: RocksDBの概要
summary: RocksDBの基本コンセプトと動作原理を学びます。
category: 参照

# RocksDBの概要

[RocksDB](https://github.com/facebook/rocksdb)は、キー・値ストアと読み書き機能を提供するLSM木ストレージエンジンです。Facebookによって開発され、LevelDBを基にしています。ユーザーが書き込むキー・値ペアは、まずWrite Ahead Log (WAL) に挿入され、その後メモリ内のSkipListに書き込まれます（これをMemTableと呼ばれるデータ構造）。LSM木エンジンは、ランダムな変更（挿入）をWALファイルに順次書き込むため、Bツリーエンジンよりも良い書き込みスループットを提供します。

メモリ内のデータが一定のサイズに達すると、RocksDBはそれをディスク上のソートされた文字列テーブル（SST）ファイルにフラッシュします。SSTファイルは複数のレベルに構成されています（デフォルトでは最大6つのレベル）。あるレベルの合計サイズが閾値に達すると、RocksDBは一部のSSTファイルを選択し、次のレベルにマージします。各後続レベルは前のレベルの10倍のサイズであり、そのためデータの90%は最後の層に格納されます。

RocksDBでは、複数のColumn Family（CF）を作成することができます。CFにはそれぞれ独自のSkipListとSSTファイルがあり、同じWALファイルを共有します。これにより、異なるCFはアプリケーションの特性に応じて異なる設定を持つことができます。これにより、同時にWALへの書き込み回数は増加しません。

## TiKVアーキテクチャ

TiKVのアーキテクチャは以下のようになっています：

![TiKV RocksDB](/media/tikv-rocksdb.png)

ストレージエンジンとしてのRocksDBは、Raftログとユーザーデータの保存に使用されます。TiKVノードのすべてのデータは2つのRocksDBインスタンスを共有します。1つはRaftログ用（一般的にraftdbと呼ばれます）、もう1つはユーザーデータおよびMVCCメタデータ用（一般的にkvdbと呼ばれます）。kvdbには4つのCFがあります: raft、lock、default、write:

* raft CF: 各リージョンのメタデータを保存します。非常に少量のスペースしか占有せず、ユーザーはそれを気にする必要はありません。
* lock CF: 悲観的トランザクションの悲観的ロックと分散トランザクションのPrewriteロックを保存します。トランザクションがコミットされると、lock CF内の対応するデータは迅速に削除されます。したがって、lock CF内のデータ量は通常非常に少量です（1 GB未満）。lock CF内のデータが大幅に増えると、多数のトランザクションがコミットを待っていることを意味し、システムにバグや障害が発生していることを意味します。
* write CF: ユーザーの実際の書き込まれたデータおよびMVCCメタデータ（データが属するトランザクションの開始タイムスタンプおよびコミットタイムスタンプ）を保存します。ユーザーが行のデータを書き込むと、データの長さが255バイト未満であればwrite CFに保存されます。それ以外の場合は、デフォルトCFに保存されます。TiDBでは、セカンダリインデックスは非ユニークインデックスに保存される値が空であり、ユニークインデックスに保存される値がプライマリキーインデックスであるため、セカンダリインデックスはwrite CFのスペースのみを占有します。
* default CF: 255バイト以上のデータを保存します。

## RocksDBのメモリ使用量

読み取り性能を向上させ、ディスクへの読み取り操作を減らすために、RocksDBはディスク上に保存されたファイルを一定のサイズ（デフォルトは64 KB）でブロックに分割します。ブロックを読み取る際には、まずメモリ内のBlockCacheにデータが既に存在するかどうかを確認します。その場合、データをディスクにアクセスせずにメモリから直接読み取ることができます。

BlockCacheはLRUアルゴリズムに従って最も最近使用されていないデータを破棄します。デフォルトでは、TiKVはシステムメモリの45%をBlockCacheに割り当てます。ユーザーは`storage.block-cache.capacity`の構成を適切な値に変更することもできます。ただし、合計システムメモリの60%を超えることは推奨されません。

RocksDBに書き込まれるデータはまずMemTableに書き込まれます。メモリテーブルのサイズが128 MBを超えると、新しいMemTableに切り替わります。TiKVには2つのRocksDBインスタンスがあり、合計4つのCFがあります。各CFの単一のMemTableのサイズ制限は128 MBです。同時に存在できるMemTableは最大5つであります。そうでない場合、前台の書き込みがブロックされます。この部分が占有するメモリの最大値は 2.5 GB（4 x 5 x 128 MB）です。これを変更することは推奨されません。

## RocksDBのスペース使用量

* マルチバージョン: RocksDBはLSM木構造のキー・値ストレージエンジンであるため、MemTableのデータはまずL0にフラッシュされます。ファイルが生成された順序に従って配置されるため、L0のSST間には重複が生じることがあります。その結果、L0において同じキーに複数のバージョンが存在することがあります。L0からL1にファイルがマージされると、一定のサイズ（デフォルトは 8 MB）で複数のファイルに分割されます。同じレベルの各ファイルのキー範囲はお互いに重複しないため、L1およびそれ以降のレベルでは各キーについて1つのバージョンしか存在しません。
* スペース増幅: 各レベルのファイルの合計サイズは前のレベルのx倍（デフォルトは10）であり、そのためデータの90%が最後のレベルに格納されます。RocksDBのスペース増幅が1.11を超えることはありません（L0にはデータが少なく、無視できます）。
* TiKVのスペース増幅: TiKVには独自のMVCC戦略があります。ユーザーがキーを書き込むと、RocksDBに実際に書き込まれるデータはキー + commit_ts です。つまり、更新および削除は新しいキーをRocksDBに書き込みます。TiKVは古いデータを削除するため（RocksDBのDeleteインターフェースを介して）、実際のデータ保存スペースは約1.11倍になります（promptlyが古いデータをクリーンアップすると仮定）。

## RocksDBのバックグラウンドスレッドおよびコンパクション

RocksDBでは、MemTableをSSTファイルに変換したり、さまざまなレベルでSSTファイルをマージしたりする操作はバックグラウンドスレッドプールで行われます。バックグラウンドスレッドプールのデフォルトサイズは8です。マシンのCPU数が8以下の場合、バックグラウンドスレッドプールのデフォルトサイズはCPU数から1を引いた数です。

一般的に、ユーザーはこの構成を変更する必要はありません。ユーザーが1台のマシンに複数のTiKVインスタンスを展開するか、マシンの読み取り負荷が比較的高く書き込み負荷が低い場合、適切に`rocksdb/max-background-jobs`を3または4に調整できます。

## WriteStall

<CustomContent platform="tidb-cloud">

> **注意:**
>
> このセクションはTiDBに関するものであり、TiDB Cloudには適用されません。

</CustomContent>

RocksDBのL0は他のレベルとは異なります。L0のSSTは生成順に配置されます。SST間のキー範囲は重複することがあります。したがって、クエリを実行する際には、L0にあるファイルごとに順次クエリする必要があります。クエリのパフォーマンスに影響を与えないように、L0にファイルが多すぎる場合にはWriteStallがトリガーされて書き込みをブロックします。

書き込みの遅延が急激に増加する場合、まずGrafana RocksDB KVパネルの **WriteStall Reason** メトリックを確認できます。L0のファイルが多すぎるためにWriteStallが発生している場合、以下の構成を64に調整することができます。

```
rocksdb.defaultcf.level0-slowdown-writes-trigger
rocksdb.writecf.level0-slowdown-writes-trigger
rocksdb.lockcf.level0-slowdown-writes-trigger
rocksdb.defaultcf.level0-stop-writes-trigger
rocksdb.writecf.level0-stop-writes-trigger
rocksdb.lockcf.level0-stop-writes-trigger
```