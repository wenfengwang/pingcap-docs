---
title: GCの概要
summary: TiDBでGarbage Collectionについて学びます。
aliases: ['/docs/dev/garbage-collection-overview/','/docs/dev/reference/garbage-collection/overview/']
---

# GCの概要

TiDBはMVCCを使用してトランザクションの同時実行を制御します。データを更新する際、元のデータはすぐに削除されず、新しいデータと共にタイムスタンプでバージョンを区別して保持されます。Garbage Collection（GC）の目標は、不要なデータをクリアすることです。

## GCプロセス

各TiDBクラスタには、GCプロセスを制御するGCリーダーとして選択されるTiDBインスタンスが含まれています。

GCは定期的にTiDBで実行されます。各GCでは、まずTiDBが「セーフポイント」と呼ばれるタイムスタンプを計算します。その後、TiDBはセーフポイント以降のすべてのスナップショットがデータの整合性を保持する前提で、不要なデータをクリアします。具体的には、各GCプロセスには次の3つのステップが含まれます。

1. ロックを解決する。このステップでは、TiDBはセーフポイント前のすべてのリージョンでロックをスキャンし、これらのロックをクリアします。
2. 範囲を削除する。このステップでは、`DROP TABLE`/`DROP INDEX`操作から生成された範囲全体の不要なデータを迅速にクリアします。
3. GCを実行する。このステップでは、各TiKVノードがそれぞれのデータをスキャンし、各キーの不要な古いバージョンを削除します。

デフォルトの構成では、GCは10分ごとにトリガーされます。各GCでは、最近の10分間のデータが保持され、つまりGCの寿命はデフォルトで10分（セーフポイント＝現在の時刻−GC寿命）です。1つのGCラウンドが長時間実行されている場合、そのGCが完了する前に次のGCをトリガーしても、次のGCはトリガーされません。また、GC寿命を超えた長時間のトランザクションが正常に実行されるようにするために、セーフポイントが開始時間（start_ts）を超えないようにします。

## 実装の詳細

### ロックを解決する

TiDBトランザクションモデルは、[GoogleのPercolator](https://ai.google/research/pubs/pub36726)をベースに実装されています。これは主に実用的な最適化を加えた2フェーズコミットプロトコルです。第1フェーズが終了すると、関連するすべてのキーがロックされます。これらのロックの中には、1つはプライマリロックであり、他のものはプライマリロックへのポインタが含まれるセカンダリロックです。第2フェーズでは、プライマリロックを持つキーに書き込みレコードが与えられ、そのロックが削除されます。書き込みレコードは、そのキーの過去の書き込みまたは削除操作、またはそのトランザクショナルなロールバックレコードを示します。プライマリロックを置き換える書き込みレコードの種類は、対応するトランザクションが成功裏にコミットされたかどうかを示します。その後、すべてのセカンダリロックが順次置き換えられます。障害などの理由でこれらのセカンダリロックが保持され、置き換えられない場合でも、セカンダリロックの情報を元にプライマリキーを検索し、プライマリキーがコミットされたかどうかに基づいてトランザクション全体がコミットされたかどうかを判断できます。しかし、プライマリキーの情報がGCによってクリアされ、このトランザクションに未コミットのセカンダリロックが存在する場合、これらのロックがコミットされるかどうかを絶対に把握することはできません。その結果、データの整合性が保証されなくなります。

ロックを解決するステップでは、セーフポイント前のロックをクリアします。これは、ロックのプライマリキーがコミットされている場合、このロックをコミットする必要があることを意味します。そうでない場合はロールバックする必要があります。プライマリキーがまだロックされている場合（コミットされていないかロールバックされていない場合）、このトランザクションはタイムアウトと見なされ、ロールバックされます。

ロックを解決するステップは、次の2つの方法のいずれかで実装されており、システム変数[`tidb_gc_scan_lock_mode`](/system-variables.md#tidb_gc_scan_lock_mode-new-in-v50)を使用して構成できます。

> **警告:**
>
> 現在、`PHYSICAL`（Green GC）は実験的な機能です。本番環境では使用しないことをお勧めします。

- `LEGACY`（デフォルト）：GCリーダーはすべてのリージョンにリクエストを送信して古いロックをスキャンし、スキャンされたロックのプライマリキーの状態をチェックし、対応するトランザクションをコミットまたはロールバックするリクエストを送信します。
- `PHYSICAL`：TiDBはRaftレイヤを経由せず、各TiKVノード上のデータを直接スキャンします。

### 範囲を削除する

`DROP TABLE/INDEX`などの操作中に連続するキーを持つ大量のデータが削除されます。それぞれのキーを削除し、後でそれらに対してGCを実行すると、ストレージの回収効率が低下する可能性があります。そのようなシナリオでは、TiDBは実際に各キーを削除しません。代わりに、削除する範囲と削除のタイムスタンプのみを記録します。その後、削除範囲ステップは、セーフポイントより前のタイムスタンプの範囲を素早く物理的に削除します。

### GCを実行する

GCステップは、すべてのキーの古いバージョンをクリアします。セーフポイント以降のすべてのタイムスタンプが一貫したスナップショットを持つことを保証するために、このステップはセーフポイントより前にコミットされたデータを削除しますが、セーフポイントより前の各キーの最後の書き込みが削除でない限り、その書き込みを保持します。

このステップでは、TiDBはPDにセーフポイントを送信するだけで、GCのラウンド全体が完了します。TiKVは自動的にセーフポイントの変更を検出し、現在のノード上のすべてのリージョンのGCを実行します。同時に、GCリーダーは次のGCラウンドをトリガーし続けることができます。

> **注意:**
>
> TiDB 5.0以降、GCステップでは常に`DISTRIBUTED` gcモードが使用されます。これにより、以前の`CENTRAL` gcモードが置換されます。このモードは、TiDBサーバが各リージョンにGCリクエストを送信する方式でした。