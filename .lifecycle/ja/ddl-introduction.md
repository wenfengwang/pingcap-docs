---
title: DDL ステートメントの実行原則とベストプラクティス
summary: TiDB での DDL ステートメントの実装方法、オンライン変更プロセス、およびベストプラクティスについて学びます。
---

# DDL ステートメントの実行原則とベストプラクティス

このドキュメントでは、TiDB における DDL ステートメントに関連する実行原則とベストプラクティスの概要を提供します。原則には DDL オーナーモジュールとオンライン DDL 変更プロセスが含まれます。

## DDL 実行原則

TiDB はオンラインで非同期なアプローチを使用して DDL ステートメントを実行します。これは、DDL ステートメントの実行中に他のセッションの DML ステートメントがブロックされないことを意味します。つまり、アプリケーションが実行中でもオンラインおよび非同期の DDL ステートメントを使用してデータベースオブジェクトの定義を変更できます。

### DDL ステートメントの種類

DDL ステートメントが実行中にユーザーアプリケーションをブロックするかどうかに基づいて、DDL ステートメントは次のタイプに分類できます：

- **オフライン DDL ステートメント**：データベースがユーザーからの DDL ステートメントを受信すると、最初に変更するデータベースオブジェクトをロックし、その後メタデータを変更します。DDL 実行中、データベースはデータの修正をユーザーアプリケーションからブロックします。

- **オンライン DDL ステートメント**：データベースで DDL ステートメントを実行すると、特定の方法が使用されて、ステートメントがユーザーアプリケーションをブロックしないようにします。これにより、ユーザーはDDL 実行中に修正を送信することができます。この方法は実行プロセス中に対応するデータベースオブジェクトの正確性と整合性も確保します。

データベースオブジェクトに含まれるデータを操作するかどうかに基づいて、DDL ステートメントは次のタイプに分類できます：

- **論理 DDL ステートメント**：論理 DDL ステートメントは通常、データベースオブジェクトのメタデータのみを変更し、オブジェクトに格納されているデータを処理しません。たとえば、テーブル名を変更したり、列名を変更したりします。

    TiDB では、論理 DDL ステートメントは「汎用 DDL」とも呼ばれます。これらのステートメントは通常、数十ミリ秒から数秒で完了することが多いため、システムリソースをあまり消費せず、アプリケーションのワークロードに影響を与えません。

- **物理 DDL ステートメント**：物理 DDL ステートメントは、変更されるオブジェクトのメタデータだけでなく、オブジェクトに格納されているユーザーデータも変更します。たとえば、TiDB がテーブルにインデックスを作成する際、テーブルの定義だけでなく、新しく追加されたインデックスを構築するためにフルテーブルスキャンを実行します。

    TiDB では、物理 DDL ステートメントは「再編 DDL」とも呼ばれ、再構築を意味します。現在、物理 DDL ステートメントには `ADD INDEX` と劣化カラム型の変更（たとえば `INT` 型から `CHAR` 型に変更する）が含まれます。これらのステートメントの実行には長い時間がかかり、実行時間はテーブル内のデータ量、マシン構成、およびアプリケーションのワークロードに影響を受けます。

    物理 DDL ステートメントの実行は、2つの理由でアプリケーションのワークロードに影響を与える可能性があります。一方で、TiKVからデータを読み取り、新しいデータを書き込むため、CPU および I/O リソースを消費します。他方で、DDL オーナーが存在する TiDB ノードは対応する計算を実行する必要があり、CPU リソースをさらに消費します。TiDB はDDL ステートメントの分散実行をサポートしていないため、このプロセス中に他の TiDB ノードは追加のシステムリソースを消費しません。

    > **注意:**
    >
    > 物理 DDL タスクの実行は通常、ユーザーアプリケーションに最も大きな影響を与えます。そのため、この影響を最小限に抑えるための鍵は、物理 DDL ステートメントの設計を最適化することです。これにより、ユーザーアプリケーションへの影響を減らすのに役立ちます。

### TiDB DDL モジュール

TiDB DDL モジュールには DDL オーナー（またはオーナー）の役割が導入されており、TiDB クラスタ内でのすべての DDL ステートメントの実行に対するプロキシとして機能します。現在の実装では、クラスタ全体の TiDB ノードで唯一の TiDB ノードが任意のタイミングでオーナーとして選出されます。TiDB ノードがオーナーとして選ばれると、その TiDB ノードで開始されたワーカーがクラスタ内の DDL タスクを処理できます。

TiDB は etcd の選挙メカニズムを使用して、複数の TiDB ノードからオーナーをホストするノードを選出します。デフォルトでは、各 TiDB ノードはオーナーに選出される可能性があります（`run-ddl` を構成して選出プロセスにノードを参加させることができます）。選出されたオーナーノードには期間があり、それを更新して活性化します。オーナーノードがダウンした場合、別のノードが etcd を介して新しいオーナーとして選出され、クラスタ内の DDL タスクを継続して実行します。

DDL オーナーの簡単な説明は次のとおりです：

![DDL オーナー](/media/ddl-owner.png)

現在の DDL オーナーを表示するには、`ADMIN SHOW DDL` ステートメントを使用できます：

```sql
ADMIN SHOW DDL;
```

```sql
+------------+--------------------------------------+---------------+--------------+--------------------------------------+-------+
| SCHEMA_VER | OWNER_ID                             | OWNER_ADDRESS | RUNNING_JOBS | SELF_ID                              | QUERY |
+------------+--------------------------------------+---------------+--------------+--------------------------------------+-------+
|         26 | 2d1982af-fa63-43ad-a3d5-73710683cc63 | 0.0.0.0:4000  |              | 2d1982af-fa63-43ad-a3d5-73710683cc63 |       |
+------------+--------------------------------------+---------------+--------------+--------------------------------------+-------+
1 row in set (0.00 sec)
```

### TiDB におけるオンライン DDL 非同期変更の仕組み

設計の初めから、TiDB DDL モジュールはオンライン非同期変更モードを採用しています。これにより、ダウンタイムを経験することなくアプリケーションを変更できます。

DDL 変更は通常、1つの状態から別の状態に移行することを伴います。オンライン DDL 変更では、この遷移は互いに互換性のある複数の小さなバージョンの状態を導入することで行われます。DDL ステートメントの実行中、クラスタ内の TiDB ノードは異なる小さなバージョンの変更オブジェクトを持つことが許可されますが、隣接する小さなバージョン間の差が2つ以上でなければなりません。これは隣接する小さなバージョンが互いに互換性があるため可能です。

このように、複数の小さなバージョンを通る進化により、複数の TiDB ノード間でメタデータが正しく同期されることが保証されます。これにより、プロセス中にデータを変更するユーザートランザクションの正確性と整合性が維持されます。

`ADD INDEX` を取ってみると、状態変更の完全なプロセスは次のとおりです：

```
absent -> delete only -> write only -> write reorg -> public
```

ユーザーにとって、`public` 状態では新しく作成されたインデックスは利用できません。

<SimpleTab>
<div label="TiDB v6.2.0 より前のオンライン DDL 非同期変更">

v6.2.0 より前では、TiDB SQL レイヤーにおける非同期スキーマ変更の処理プロセスは次のとおりです：

1. MySQL クライアントが TiDB サーバーに DDL リクエストを送信します。

2. リクエストを受信すると、TiDB サーバーは MySQL プロトコルレイヤーでリクエストを解析し最適化し、その後 TiDB SQL レイヤーに実行を送信します。

    TiDB の SQL レイヤーが DDL リクエストを受け取ると、`start job` モジュールを開始してリクエストを特定の DDL Job（つまり DDL タスク）にカプセル化し、ステートメントのタイプに応じて対応する DDL ジョブキューにこのジョブを格納します。対応するワーカーには処理が必要なジョブが通知されます。

3. ジョブを処理するための通知を受信すると、ワーカーは DDL オーナーの役割を持っているかどうかを判断します。役割を持っていれば、そのままジョブを処理します。持っていない場合は、処理をせずに終了します。

    TiDB サーバーにオーナの役割がない場合、別のノードでオーナが存在することを定期的にチェックします。ジョブを実行できるジョブが特定されると、そのワーカーがそのジョブを処理します。

4. ワーカーがジョブを処理した後、そのジョブを KV レイヤのジョブキューから削除し、`job history queue` に配置します。ジョブをカプセル化した `start job` モジュールは、`job history queue` の ID を定期的にチェックして処理されたかどうかを確認します。処理が完了している場合、そのジョブに対応するすべての DDL 操作が終了します。

5. TiDB サーバーは DDL 処理結果を MySQL クライアントに返します。

TiDB v6.2.0 より前では、DDL 実行フレームワークには次の制限がありました：

- TiKV クラスタには `general job queue` と `add index job queue` のみのキューがあり、論理 DDL および物理 DDL をそれぞれ処理します。
- DDL オーナーは常に DDL ジョブを FIFO 方式で実行します。
- DDL オーナーは同じタイプの DDL タスク（論理または物理）を同時に 1 つしか実行できないため、比較的厳格で、ユーザーエクスペリエンスに影響を与えます。

これらの制限により、意図しない DDL ブロック動作が発生する可能性があります。詳細は、[SQL FAQ - DDL Execution](https://docs.pingcap.com/tidb/stable/sql-faq#ddl-execution) を参照してください。

</div>
<div label="v6.2.0 からの並列 DDL フレームワーク">

v6.2.0 より前の TiDB では、タイプが同じ（論理または物理）の DDL タスクを同時に 1 つしか実行できないため、DDL オーナーがユーザーエクスペリエンスに影響を与えることになります。

DDLタスク間に依存関係がない場合、並行実行はデータの正確性と整合性に影響を与えません。たとえば、ユーザーAが`T1`テーブルにインデックスを追加し、ユーザーBが`T2`テーブルから列を削除する場合、これらの2つのDDLステートメントは並行して実行できます。

DDL実行のユーザーエクスペリエンスを向上させるために、v6.2.0から、TiDBはDDLタスクの関連性をDetermineする機能をOwnersに提供しています。その仕組みは以下のとおりです。

+ 同じテーブルに実行されるDDLステートメントは互いにブロックされます。
+ `DROP DATABASE`およびデータベース内のすべてのオブジェクトに影響するDDLステートメントは互いにブロックされます。
+ 異なるテーブルでのインデックスの追加および列の型変更は並列に実行できます。
+ 論理DDLステートメントは前の論理DDLステートメントの実行を待ってから実行できます。
+ その他の場合は、並行DDL実行の可用性レベルに基づいてDDLを実行できます。

具体的には、TiDBはv6.2.0でDDL実行フレームワークを以下の点でアップグレードしました。

+ DDL Ownerは、前述のロジックに基づいてDDLタスクを並行して実行できます。
+ DDLジョブキューでのFIFO問題が解決されました。DDL Ownerはもはやキュー内の最初のジョブを選択せず、代わりに現在の時点で実行できるジョブを選択します。
+ 物理DDLステートメントを処理するワーカーの数が増え、複数の物理DDLステートメントを並行して実行できるようになりました。

TiDBのすべてのDDLタスクはオンライン変更アプローチを使用して実装されているため、TiDBはOwnersを介して新しいDDLタスクの関連性を確定し、この情報に基づいてDDLタスクをスケジュールできます。このアプローチにより、分散データベースは従来のデータベースと同等のDDL並行性を実現できます。

並行DDLフレームワークはTiDBのDDLステートメントの実行能力を高め、商用データベースの使用パターンとの互換性を高めます。

</div>
</SimpleTab>

## ベストプラクティス

### 物理DDL実行速度とアプリケーション負荷への影響のバランスをシステム変数で調整する

物理DDLステートメント（インデックスの追加や列の型変更を含む）を実行する際に、以下のシステム変数の値を調整し、DDL実行速度とアプリケーション負荷への影響をバランスさせることができます。

- [`tidb_ddl_reorg_worker_cnt`](/system-variables.md#tidb_ddl_reorg_worker_cnt): この変数はDDL操作の再構成ワーカー数を設定し、バックフィリングの並列性を制御します。

- [`tidb_ddl_reorg_batch_size`](/system-variables.md#tidb_ddl_reorg_batch_size): この変数は、DDL操作の「再構成」フェーズでのバッチサイズを設定し、バックフィルするデータ量を制御します。

    推奨値:

    - 他の負荷がない場合、`tidb_ddl_reorg_worker_cnt`および`tidb_ddl_reorg_batch_size`の値を増やして`ADD INDEX`操作の速度を上げることができます。たとえば、これら2つの変数の値をそれぞれ`20`および`2048`に設定できます。
    - 他の負荷がある場合、`tidb_ddl_reorg_worker_cnt`および`tidb_ddl_reorg_batch_size`の値を減らして、他のアプリケーションに与える影響を最小限に抑えることができます。たとえば、これらの変数の値をそれぞれ`4`および`256`に設定できます。

> **ヒント:**
>
> - 上記の2つの変数はDDLタスクの実行中に動的に調整でき、次のトランザクションバッチで効果が発揮されます。
> - オペレーションのタイプとアプリケーションの負荷圧力に基づいて、DDL操作の実行タイミングを適切に選択してください。たとえば、アプリケーション負荷が低いときに`ADD INDEX`操作を実行することをお勧めします。
> - インデックスの追加の実行時間が比較的長いため、TiDBはコマンド送信後バックグラウンドでタスクを実行します。TiDBサーバーが停止しても実行に影響を与えません。

### 複数のDDLリクエストを並行して送信して多くのテーブルを迅速に作成する

テーブルの作成操作には約50ミリ秒かかります。枠組みの制限により、テーブルの作成にかかる実際の時間は長くなる場合があります。

テーブルをより速く作成するためには、最速のテーブル作成速度を達成するために、複数のDDLリクエストを並列して送信することが推奨されます。DDLリクエストを直列で送信せず、Ownersノードに送らないと、テーブルの作成速度は非常に遅くなります。

### 単一の`ALTER`ステートメントで複数の変更を行う

v6.2.0から、TiDBは単一の`ALTER`ステートメントでテーブルの複数のスキーマオブジェクト（列やインデックスなど）を変更することをサポートしていますが、その際にステートメント全体の原子性を保証します。したがって、単一の`ALTER`ステートメントで複数の変更を行うことをお勧めします。

### 読み書きパフォーマンスを確認する

TiDBがインデックスの追加中に、データのバックフィリングフェーズはクラスタに読み書きの圧力を引き起こします。`ADD INDEX`コマンドを送信して`write reorg`フェーズが開始された後、TiDBおよびTiKVの読み書きパフォーマンスメトリクスおよびアプリケーションの応答時間をGrafanaダッシュボードで確認し、`ADD INDEX`操作がクラスタに影響を与えるかどうかを判断することが推奨されます。

## DDL関連コマンド

- `ADMIN SHOW DDL`: TiDBのDDL操作のステータスを表示するために使用され、現在のスキーマバージョン番号、DDLの所有者のDDL IDとアドレス、実行中のDDLタスクやSQL、現在のTiDBインスタンスのDDL IDなどを含みます。詳細については、[`ADMIN SHOW DDL`](/sql-statements/sql-statement-admin-show-ddl.md#admin-show-ddl)を参照してください。

- `ADMIN SHOW DDL JOBS`: クラスタ環境で実行中のDDLタスクの詳細状況を表示するために使用されます。詳細については、[`ADMIN SHOW DDL JOBS`](/sql-statements/sql-statement-admin-show-ddl.md#admin-show-ddl-jobs)を参照してください。

- `ADMIN SHOW DDL JOB QUERIES job_id [, job_id]`: `job_id`に対応するDDLタスクの元のSQLステートメントを表示するために使用されます。詳細については、[`ADMIN SHOW DDL JOB QUERIES`](/sql-statements/sql-statement-admin-show-ddl.md#admin-show-ddl-job-queries)を参照してください。

- `ADMIN CANCEL DDL JOBS job_id, [, job_id]`: 提出されている未完了のDDLタスクをキャンセルするために使用されます。キャンセルが完了すると、DDLタスクを実行するSQLステートメントは`ERROR 8214 (HY000): Cancelled DDL job`エラーを返します。

    完了したDDLタスクをキャンセルすると、`RESULT`列に`DDL Job:90 not found`エラーが表示され、タスクがDDL待機キューから削除されたことを意味します。

- `ADMIN PAUSE DDL JOBS job_id [, job_id]`: 実行中のDDLタスクを一時停止するために使用されます。コマンドが実行されると、DDLタスクを実行しているSQLステートメントは実行中のままですが、バックグラウンドタスクは一時停止されます。詳細については、[`ADMIN PAUSE DDL JOBS`](/sql-statements/sql-statement-admin-pause-ddl.md)を参照してください。

    実行中ではないまたはまだキューにあるDDLタスクは一時停止できません。それ以外の場合、`RESULT`列に`Job 3 can't be paused now`エラーが表示されます。

- `ADMIN RESUME DDL JOBS job_id [, job_id]`: 一時停止されたDDLタスクを再開するために使用されます。コマンドが実行されると、DDLタスクを実行しているSQLステートメントは実行中のままであり、バックグラウンドタスクが再開されます。詳細については、[`ADMIN RESUME DDL JOBS`](/sql-statements/sql-statement-admin-resume-ddl.md)を参照してください。

    一時停止されたDDLタスクのみを再開できます。それ以外の場合、`RESULT`列に`Job 3 can't be resumed`エラーが表示されます。

## よくある質問

DDL実行に関する一般的な質問については、[SQL FAQ - DDL execution](https://docs.pingcap.com/tidb/stable/sql-faq)を参照してください。