---
title: キャッシュされたテーブル
summary: TiDBで使用されるほとんど更新されない小さなホットスポットテーブルの読み取りパフォーマンスを向上させるためのキャッシュされたテーブル機能を学びます。

---

# キャッシュされたテーブル

TiDB v6.0.0 で、TiDBは頻繁にアクセスされるがほとんど更新されない小さなホットスポットテーブルのためのキャッシュされたテーブル機能を導入します。この機能を使用すると、TiDBサーバーのメモリにテーブル全体のデータがロードされ、TiDBはTiKVにアクセスせずに直接表データをメモリから取得するため、読み取りパフォーマンスが向上します。

このドキュメントでは、キャッシュされたテーブルの使用シナリオ、例、および他のTiDB機能との互換性制限について説明します。

## 使用シナリオ

キャッシュされたテーブル機能は、以下の特性を持つテーブルに適しています。

- テーブルのデータ量が少ない
- テーブルが読み取り専用またはほとんど更新されない
- テーブルが頻繁にアクセスされ、より良い読み取りパフォーマンスを期待する

テーブルのデータ量が少ないがデータが頻繁にアクセスされる場合、データはTiKVのリージョンに集中し、ホットスポットリージョンになりパフォーマンスに影響を与えます。そのため、キャッシュされたテーブルの典型的な使用シナリオは次の通りです。

- アプリケーションが構成情報を読み取る構成テーブル
- 金融部門の為替レートテーブル。これらのテーブルは1日1回のみ更新され、リアルタイムではありません。
- ほとんど更新されない銀行支店またはネットワーク情報テーブル

構成テーブルを例に取ると、アプリケーションが再起動すると、構成情報はすべての接続にロードされ、読み取り遅延が発生します。この場合、キャッシュされたテーブル機能を使用してこの問題を解決できます。

## 例

このセクションでは、例を使用してキャッシュされたテーブルの使用方法を説明します。

### 通常のテーブルをキャッシュされたテーブルに設定する

テーブル `users` があるとします。

{{< copyable "sql" >}}

```sql
CREATE TABLE users (
    id BIGINT,
    name VARCHAR(100),
    PRIMARY KEY(id)
);
```

このテーブルをキャッシュされたテーブルに設定するには、`ALTER TABLE` ステートメントを使用します。

{{< copyable "sql" >}}

```sql
ALTER TABLE users CACHE;
```

```sql
Query OK, 0 rows affected (0.01 sec)
```

### キャッシュされたテーブルを検証する

キャッシュされたテーブルを検証するには、`SHOW CREATE TABLE` ステートメントを使用します。テーブルがキャッシュされている場合、返される結果に `CACHED ON` 属性が含まれます。

{{< copyable "sql" >}}

```sql
SHOW CREATE TABLE users;
```

```sql
+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                                                                               |
+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| users | CREATE TABLE `users` (
  `id` bigint(20) NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`) /*T![clustered_index] CLUSTERED */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin /* CACHED ON */ |
+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

キャッシュされたテーブルからデータを読み取った後、TiDBはデータをメモリにロードします。データがロードされていない場合、返される結果に `regionRequest.SendReqCtx` 属性が含まれ、TiDBがTiKVからデータを読み取っていることを示します。

{{< copyable "sql" >}}

```sql
TRACE SELECT * FROM users;
```

```sql
+------------------------------------------------+-----------------+------------+
| operation                                      | startTS         | duration   |
+------------------------------------------------+-----------------+------------+
| trace                                          | 17:47:39.969980 | 827.73µs   |
|   ├─session.ExecuteStmt                        | 17:47:39.969986 | 413.31µs   |
|   │ ├─executor.Compile                         | 17:47:39.969993 | 198.29µs   |
|   │ └─session.runStmt                          | 17:47:39.970221 | 157.252µs  |
|   │   └─TableReaderExecutor.Open               | 17:47:39.970294 | 47.068µs   |
|   │     └─distsql.Select                       | 17:47:39.970312 | 24.729µs   |
|   │       └─regionRequest.SendReqCtx           | 17:47:39.970454 | 189.601µs  |
|   ├─*executor.UnionScanExec.Next               | 17:47:39.970407 | 353.073µs  |
|   │ ├─*executor.TableReaderExecutor.Next       | 17:47:39.970411 | 301.106µs  |
|   │ └─*executor.TableReaderExecutor.Next       | 17:47:39.970746 | 6.57µs     |
|   └─*executor.UnionScanExec.Next               | 17:47:39.970772 | 17.589µs   |
|     └─*executor.TableReaderExecutor.Next       | 17:47:39.970776 | 6.59µs     |
+------------------------------------------------+-----------------+------------+
12 rows in set (0.01 sec)
```

もう一度 `trace` を実行した後、返される結果にはもはや `regionRequest.SendReqCtx` 属性が含まれず、TiDBがTiKVからデータを読み取るのではなく、代わりにメモリからデータを読み取ることを示します。

{{< copyable "sql" >}}

```sql
+----------------------------------------+-----------------+------------+
| operation                              | startTS         | duration   |
+----------------------------------------+-----------------+------------+
| trace                                  | 17:47:40.533888 | 453.547µs  |
|   ├─session.ExecuteStmt                | 17:47:40.533894 | 402.341µs  |
|   │ ├─executor.Compile                 | 17:47:40.533903 | 205.54µs   |
|   │ └─session.runStmt                  | 17:47:40.534141 | 132.084µs  |
|   │   └─TableReaderExecutor.Open       | 17:47:40.534202 | 14.749µs   |
|   ├─*executor.UnionScanExec.Next       | 17:47:40.534306 | 3.21µs     |
|   └─*executor.UnionScanExec.Next       | 17:47:40.534316 | 1.219µs    |
+----------------------------------------+-----------------+------------+
7 rows in set (0.00 sec)
```

キャッシュされたテーブルへの読み込みに `UnionScan` オペレータが使用されるため、`explain` を使用してキャッシュされたテーブルの実行計画を調べることができます。

{{< copyable "sql" >}}

```sql
+-------------------------+---------+-----------+---------------+--------------------------------+
| id                      | estRows | task      | access object | operator info                  |
+-------------------------+---------+-----------+---------------+--------------------------------+
| UnionScan_5             | 1.00    | root      |               |                                |
| └─TableReader_7         | 1.00    | root      |               | data:TableFullScan_6           |
|   └─TableFullScan_6     | 1.00    | cop[tikv] | table:users   | keep order:false, stats:pseudo |
+-------------------------+---------+-----------+---------------+--------------------------------+
3 rows in set (0.00 sec)
```

### キャッシュされたテーブルにデータを書き込む

キャッシュされたテーブルはデータ書き込みをサポートしています。例えば、`users` テーブルにレコードを挿入することができます。

{{< copyable "sql" >}}

```sql
INSERT INTO users(id, name) VALUES(1001, 'Davis');
```

```sql
Query OK, 1 row affected (0.00 sec)
```

{{< copyable "sql" >}}

```sql
SELECT * FROM users;
```

```sql
+------+-------+
| id   | name  |
+------+-------+
| 1001 | Davis |
+------+-------+
1 row in set (0.00 sec)
```

> **注意:**
>
> キャッシュされたテーブルにデータを挿入すると、2次の書き込み遅延が発生する場合があります。この遅延は、グローバル環境変数 [`tidb_table_cache_lease`](/system-variables.md#tidb_table_cache_lease-new-in-v600) によって制御されます。アプリケーションに基づいて遅延が許容できるかどうかを確認して、キャッシュされたテーブル機能を使用するかどうかを決定できます。例えば、読み取り専用のシナリオでは、`tidb_table_cache_lease` の値を増やすことができます。
>
> ```sql
> set @@global.tidb_table_cache_lease = 10;
> ```
>
> キャッシュされたテーブルの書き込み遅延は高いです。なぜなら、キャッシュされたテーブル機能は、各キャッシュにリースを設定する複雑なメカニズムで実装されているためです。複数のTiDBインスタンスがある場合、1つのインスタンスは他のインスタンスがキャッシュされたデータを持っているかどうかを知らないため、もう1つのインスタンスがテーブルデータを直接変更すると、他のインスタンスは古いキャッシュデータを読み取ります。正確性を保証するために、キャッシュされたテーブルの実装は、データがリースの有効期限が切れる前に変更されないようにするために、リースメカニズムを使用します。これが書き込み遅延が高い理由です。

キャッシュされたテーブルのメタデータは、`mysql.table_cache_meta` テーブルに格納されます。このテーブルには、すべてのキャッシュされたテーブルのID、現在のロック状態（`lock_type`）、およびロックのリース情報（`lease`）が記録されています。このテーブルはTiDB内部でのみ使用され、変更しないでください。それ以外の場合、予期しないエラーが発生する可能性があります。

```sql
SHOW CREATE TABLE mysql.table_cache_meta\G
*************************** 1. row ***************************
       Table: table_cache_meta
Create Table: CREATE TABLE `table_cache_meta` (
  `tid` bigint(11) NOT NULL DEFAULT '0',
  `lock_type` enum('NONE','READ','INTEND','WRITE') NOT NULL DEFAULT 'NONE',
  `lease` bigint(20) NOT NULL DEFAULT '0',
  `oldReadLease` bigint(20) NOT NULL DEFAULT '0',
  PRIMARY KEY (`tid`) /*T![clustered_index] CLUSTERED */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
1 row in set (0.00 sec)
```

### キャッシュされたテーブルを通常のテーブルに戻す

> **注意:**
>
> キャッシュされたテーブルに対して DDL ステートメントを実行すると失敗します。キャッシュされたテーブルに対して DDL ステートメントを実行する前に、まずキャッシュ属性を削除し、キャッシュされたテーブルを通常のテーブルに戻す必要があります。

{{< copyable "sql" >}}

```sql
TRUNCATE TABLE users;
```

```sql
ERROR 8242 (HY000): 'Truncate Table' is unsupported on cache tables.
```

{{< copyable "sql" >}}

```sql
mysql> ALTER TABLE users ADD INDEX k_id(id);
```

```sql
ERROR 8242 (HY000): 'Alter Table' is unsupported on cache tables.
```

キャッシュされたテーブルを通常のテーブルに戻すには、`ALTER TABLE t NOCACHE` を使用してください:

{{< copyable "sql" >}}

```sql
ALTER TABLE users NOCACHE;
```

```sql
Query OK, 0 rows affected (0.00 sec)
```

## キャッシュされたテーブルのサイズ制限

キャッシュされたテーブルは、TiDBがテーブル全体のデータをメモリに読み込むため、小さなテーブルに適しています。また、キャッシュされたデータは変更後に無効になり、再読み込みする必要があります。

現在、TiDBにおけるキャッシュされたテーブルのサイズ制限は 64 MB です。テーブルデータが 64 MB を超えると、`ALTER TABLE t CACHE` の実行が失敗します。

## 他のTiDBの機能との互換性の制限

キャッシュされたテーブルは、以下の機能を**サポートしていません**:

- パーティションされたテーブルに対する `ALTER TABLE t ADD PARTITION` 操作はサポートされていません。
- 一時テーブルに対する `ALTER TABLE t CACHE` 操作はサポートされていません。
- ビューに対する `ALTER TABLE t CACHE` 操作はサポートされていません。
- ステールリードはサポートされていません。
- キャッシュされたテーブルに対する直接のDDL操作はサポートされていません。DDL操作を行う前に、`ALTER TABLE t NOCACHE` を使用してキャッシュされたテーブルを通常のテーブルに戻す必要があります。

キャッシュされたテーブルは、以下のシナリオで**使用できません**:

- システム変数 `tidb_snapshot` を設定して過去のデータを読み取ること。
- 変更中、キャッシュされたデータが無効になり、データが再読み込みされるまで。

## TiDB マイグレーションツールとの互換性

キャッシュされたテーブルは、MySQL構文のTiDB拡張機能です。TiDBだけが `ALTER TABLE ... CACHE` ステートメントを認識できます。BR、TiCDC、およびDumplingを含むTiDBマイグレーションツールは、キャッシュされたテーブルを**サポートしていません**。

つまり、キャッシュされたテーブルがバックアップされて復元されると、通常のテーブルになります。下流クラスターが異なるTiDBクラスターであり、キャッシュされたテーブル機能を引き続き使用したい場合は、下流テーブルで `ALTER TABLE ... CACHE` を実行して、手動でキャッシュされたテーブルを有効にする必要があります。

## 関連情報

* [ALTER TABLE](/sql-statements/sql-statement-alter-table.md)
* [システム変数](/system-variables.md)