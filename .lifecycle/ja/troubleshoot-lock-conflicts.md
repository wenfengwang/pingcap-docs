---
title: ロックの競合をトラブルシューティングする
summary: TiDB でのロックの競合を分析して解決する方法を学びます。

# ロックの競合をトラブルシューティングする

TiDB は完全な分散トランザクションをサポートしています。v3.0 以降、TiDB は楽観的トランザクションモードと悲観的トランザクションモードを提供しています。このドキュメントでは、ロックの競合問題をトラブルシューティングするためのロックビューの使用方法と、楽観的および悲観的トランザクションでの一般的なロックの競合問題の対処方法について説明します。

## ロックビューを使用してロックの問題をトラブルシューティングする

v5.1 以降、TiDB はロックビュー機能をサポートしています。この機能には、`information_schema` に組み込まれた複数のシステムテーブルがあり、これらのテーブルはロックの競合とロックの待機に関するさらなる情報を提供します。

> **注意:**
>
> 現在、ロックビュー機能は悲観的ロックの競合および待機情報のみを提供しています。

これらのテーブルの詳細な紹介については、次のドキュメントを参照してください:

* [`TIDB_TRX` および `CLUSTER_TIDB_TRX`](/information-schema/information-schema-tidb-trx.md): 現在の TiDB ノードまたはクラスタ全体で実行中のすべてのトランザクションに関する情報を提供し、そのトランザクションがロック待ち状態にあるかどうか、ロック待ち時間、トランザクションで実行されたステートメントのダイジェストを含みます。
* [`DATA_LOCK_WAITS`](/information-schema/information-schema-data-lock-waits.md): TiKV での悲観的なロック待機情報を提供し、ブロックしているトランザクションとブロックされているトランザクションの `start_ts`、ブロックされた SQL ステートメントのダイジェスト、待機が発生しているキーを含みます。
* [`DEADLOCKS` および `CLUSTER_DEADLOCKS`](/information-schema/information-schema-deadlocks.md): 現在の TiDB ノードまたはクラスタ全体で最近発生した複数のデッドロックイベントに関する情報を提供し、デッドロックループ内のトランザクション間の待機関係、現在実行中のトランザクションで実行されているステートメントのダイジェスト、待機が発生しているキーを含みます。

> **注意:**
>
> ロックビュー関連のシステムテーブルに表示される SQL ステートメントは、正規化された SQL ステートメント（すなわち、フォーマットや引数を含まない SQL ステートメント）です。これらは SQL ダイジェストに基づいて内部クエリによって取得されるため、フォーマットや引数を含む完全なステートメントを取得することはできません。SQL ダイジェストおよび正規化された SQL ステートメントの詳細については、[ステートメントサマリーテーブル](/statement-summary-tables.md)を参照してください。

次のセクションでは、これらのテーブルを使用していくつかの問題をトラブルシューティングする例を示します。

### デッドロックエラー

最近のデッドロックエラーの情報を取得するには、`DEADLOCKS` テーブルまたは `CLUSTER_DEADLOCKS` テーブルをクエリできます。

たとえば、`DEADLOCKS` テーブルをクエリするには、次の SQL ステートメントを実行できます。

{{< copyable "sql" >}}

```sql
select * from information_schema.deadlocks;
```

次に示すのは例の出力です:

```sql
+-------------+----------------------------+-----------+--------------------+------------------------------------------------------------------+-----------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------------------+--------------------+
| DEADLOCK_ID | OCCUR_TIME                 | RETRYABLE | TRY_LOCK_TRX_ID    | CURRENT_SQL_DIGEST                                               | CURRENT_SQL_DIGEST_TEXT                 | KEY                                    | KEY_INFO                                                                                           | TRX_HOLDING_LOCK   |
+-------------+----------------------------+-----------+--------------------+------------------------------------------------------------------+-----------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------------------+--------------------+
|           1 | 2021-08-05 11:09:03.230341 |         0 | 426812829645406216 | 22230766411edb40f27a68dadefc63c6c6970d5827f1e5e22fc97be2c4d8350d | update `t` set `v` = ? where `id` = ? ; | 7480000000000000355F728000000000000002 | {"db_id":1,"db_name":"test","table_id":53,"table_name":"t","handle_type":"int","handle_value":"2"} | 426812829645406217 |
|           1 | 2021-08-05 11:09:03.230341 |         0 | 426812829645406217 | 22230766411edb40f27a68dadefc63c6c6970d5827f1e5e22fc97be2c4d8350d | update `t` set `v` = ? where `id` = ? ; | 7480000000000000355F728000000000000001 | {"db_id":1,"db_name":"test","table_id":53,"table_name":"t","handle_type":"int","handle_value":"1"} | 426812829645406216 |
+-------------+----------------------------+-----------+--------------------+------------------------------------------------------------------+-----------------------------------------+----------------------------------------+----------------------------------------------------------------------------------------------------+--------------------+
```

上記のクエリ結果は、デッドロックエラーにおける複数のトランザクション間の待機関係、各トランザクションで現在実行されている SQL ステートメントの正規化された形式（フォーマットや引数を含まないステートメント）、競合が発生しているキー、キーの情報を示しています。

たとえば、上記の例では、`426812829645406216` の ID を持つトランザクションが ``update `t` set `v` =? Where `id` =? ;`` というステートメントを実行していますが、`426812829645406217` の ID を持つ別のトランザクションによってブロックされています。同様に、`426812829645406217` の ID を持つトランザクションも ``update `t` set `v` =? Where `id` =? ;`` の形式のステートメントを実行していますが、`426812829645406216` の ID を持つトランザクションによってブロックされています。これにより、これらの2つのトランザクションはデッドロックを形成しています。

### 数個のホットキーがキューイングロックを引き起こす

`DATA_LOCK_WAITS` システムテーブルは、TiKV ノード上のロック待機状態を提供します。このテーブルをクエリすると、TiDB はすべての TiKV ノードからリアルタイムのロック待機情報を自動的に取得します。数個のホットキーが頻繁にロックされ、多くのトランザクションをブロックする場合は、`DATA_LOCK_WAITS` テーブルをクエリし、キーごとに結果を集約して発生頻度の高いキーを見つけることができます:

{{< copyable "sql" >}}

```sql
select `key`, count(*) as `count` from information_schema.data_lock_waits group by `key` order by `count` desc;
```

次に示すのは例の出力です:

```sql
+----------------------------------------+-------+
| key                                    | count |
+----------------------------------------+-------+
| 7480000000000000415F728000000000000001 |     2 |
| 7480000000000000415F728000000000000002 |     1 |
+----------------------------------------+-------+
```

偶発的な発生を回避するために、複数回クエリを実行する必要があります。

問題の発生頻度が高いキーを把握している場合は、`TIDB_TRX` または `CLUSTER_TIDB_TRX` テーブルからそのキーをロックしようとするトランザクションの情報を取得できます。

`TIDB_TRX` および `CLUSTER_TIDB_TRX` テーブルに表示される情報は、クエリ実行時点で実行中のトランザクションの情報です。これらのテーブルには完了したトランザクションの情報は表示されません。大量の同時トランザクションがある場合、クエリの結果セットも大きくなる可能性があります。長時間のロック待ち時間のトランザクションをフィルタリングするために `limit` 句または `where` 句を使用することができます。また、ロックビューで複数のテーブルを結合する場合、異なるテーブルのデータは同時に取得されない可能性があるため、異なるテーブルの情報が一貫しないことに注意してください。

たとえば、`where` 句を使用して長時間のロック待ち時間のトランザクションをフィルタリングするには、次の SQL ステートメントを実行できます:

{{< copyable "sql" >}}

```sql
select trx.* from information_schema.data_lock_waits as l left join information_schema.tidb_trx as trx on l.trx_id = trx.id where l.key = "7480000000000000415F728000000000000001"\G
````sql
などの出力です:

```sql
*************************** 1. row ***************************
                     ID: 426831815660273668
             START_TIME: 2021-08-06 07:16:00.081000
     CURRENT_SQL_DIGEST: 06da614b93e62713bd282d4685fc5b88d688337f36e88fe55871726ce0eb80d7
CURRENT_SQL_DIGEST_TEXT: update `t` set `v` = `v` + ? where `id` = ? ;
                  STATE: LockWaiting
     WAITING_START_TIME: 2021-08-06 07:16:00.087720
        MEM_BUFFER_KEYS: 0
       MEM_BUFFER_BYTES: 0
             SESSION_ID: 77
                   USER: root
                     DB: test
        ALL_SQL_DIGESTS: ["0fdc781f19da1c6078c9de7eadef8a307889c001e05f107847bee4cfc8f3cdf3","06da614b93e62713bd282d4685fc5b88d688337f36e88fe55871726ce0eb80d7"]
*************************** 2. row ***************************
                     ID: 426831818019569665
             START_TIME: 2021-08-06 07:16:09.081000
```
```
     CURRENT_SQL_DIGEST: 06da614b93e62713bd282d4685fc5b88d688337f36e88fe55871726ce0eb80d7
CURRENT_SQL_DIGEST_TEXT: update `t` set `v` = `v` + ? where `id` = ? ;
                  STATE: LockWaiting
     WAITING_START_TIME: 2021-08-06 07:16:09.290271
        MEM_BUFFER_KEYS: 0
       MEM_BUFFER_BYTES: 0
             SESSION_ID: 75
                   USER: root
                     DB: test
        ALL_SQL_DIGESTS: ["0fdc781f19da1c6078c9de7eadef8a307889c001e05f107847bee4cfc8f3cdf3","06da614b93e62713bd282d4685fc5b88d688337f36e88fe55871726ce0eb80d7"]
2 行を表示 (0.00 秒)

### トランザクションが長時間ブロックされています

トランザクションが他のトランザクション（または複数のトランザクション）によってブロックされていることがわかっている場合、現在のトランザクションの `start_ts`（トランザクションID）がわかっている場合は、次の方法を使用してブロックしているトランザクションの情報を取得できます。 ロックビューで複数のテーブルを結合する場合、異なるテーブルのデータが同時に取得されない場合があるため、異なるテーブルの情報が一貫していない場合があります。

{{< copyable "sql" >}}

```sql
select l.key, trx.*, tidb_decode_sql_digests(trx.all_sql_digests) as sqls from information_schema.data_lock_waits as l join information_schema.cluster_tidb_trx as trx on l.current_holding_trx_id = trx.id where l.trx_id = 426831965449355272\G
```

次に示すのは、出力の例です。

```sql
*************************** 1. row ***************************
                    key: 74800000000000004D5F728000000000000001
               INSTANCE: 127.0.0.1:10080
                     ID: 426832040186609668
             START_TIME: 2021-08-06 07:30:16.581000
     CURRENT_SQL_DIGEST: 06da614b93e62713bd282d4685fc5b88d688337f36e88fe55871726ce0eb80d7
CURRENT_SQL_DIGEST_TEXT: update `t` set `v` = `v` + ? where `id` = ? ;
                  STATE: LockWaiting
     WAITING_START_TIME: 2021-08-06 07:30:16.592763
        MEM_BUFFER_KEYS: 1
       MEM_BUFFER_BYTES: 19
             SESSION_ID: 113
                   USER: root
                     DB: test
        ALL_SQL_DIGESTS: ["0fdc781f19da1c6078c9de7eadef8a307889c001e05f107847bee4cfc8f3cdf3","a4e28cc182bdd18288e2a34180499b9404cd0ba07e3cc34b6b3be7b7c2de7fe9","06da614b93e62713bd282d4685fc5b88d688337f36e88fe55871726ce0eb80d7"]
                   sqls: ["begin ;","select * from `t` where `id` = ? for update ;","update `t` set `v` = `v` + ? where `id` = ? ;"]
1 行を表示 (0.01 秒)
```

上記の問い合わせでは、`CLUSTER_TIDB_TRX` テーブルの `ALL_SQL_DIGESTS` 列に対して [`TIDB_DECODE_SQL_DIGESTS`](/functions-and-operators/tidb-functions.md#tidb_decode_sql_digests) 関数を使用しています。 この関数は、この列（値は SQL ダイジェストのセットです）を標準化された SQL 文に変換しようとします。 これにより可読性が向上します。

現在のトランザクションの `start_ts` が不明な場合、`TIDB_TRX` / `CLUSTER_TIDB_TRX` テーブルの情報や [`PROCESSLIST` / `CLUSTER_PROCESSLIST`](/information-schema/information-schema-processlist.md) テーブルの情報からそれを調べることができます。

## 楽観的ロックの競合を解決する

このセクションでは、楽観的トランザクションモードにおける一般的なロック競合の問題の解決策を提供します。

### 読み書き競合

TiDB サーバーは、クライアントから読み込み要求を受け取ると、現在のトランザクションの `start_ts` として物理的な時間でグローバルに一意で増加するタイムスタンプを取得します。 トランザクションは、start_ts よりも小さい最新の commit_ts のターゲットキーを読み取る必要があります。 トランザクションがターゲットキーを別のトランザクションによってロックされていることがわかり、他のトランザクションがどの段階にあるかを知ることができない場合、読み書き競合が発生します。 ダイアグラムは次のようになります：

![read-write conflict](/media/troubleshooting-lock-pic-04.png)

Txn0 は Prewrite フェーズを完了して Commit フェーズに入ります。 この時点で、Txn1 は同じターゲットキーを読み取るようにリクエストします。 Txn1 は、start_ts よりも小さい最新の commit_ts のターゲットキーを読み取る必要があります。 Txn1 の start_ts は Txn0 の lock_ts よりも大きいので、Txn1 はターゲットキーのロックが解除されるのを待たなければなりませんが、解除されていません。 その結果、Txn1 は Txn0 がコミットされたかどうかを確認できません。 したがって、Txn1 と Txn0 の間に読み書き競合が発生します。

お使いの TiDB クラスターで読み書き競合を検出する方法は次のとおりです。

1. TiDB サーバーのメトリクスおよびログの監視

    * Grafana を使用したモニタリングデータ

        TiDB ダッシュボードの `KV Errors` パネルで、`Lock Resolve OPS` の `not_expired` / `resolve`、および `KV Backoff OPS` の `tikvLockFast` は、トランザクションにおける読み書き競合をチェックするために使用できるモニタリングメトリクスです。 これらのメトリクスの値が増加すると、読み書き競合が発生している可能性があります。 `not_expired` 項目は、トランザクションのロックのタイムアウトが発生していません。 `resolve` 項目は、他のトランザクションがロックを解放しようとすることを意味します。 `tikvLockFast` 項目は、読み書き競合が発生していることを示します。

        ![KV-backoff-txnLockFast-optimistic](/media/troubleshooting-lock-pic-09.png)
        ![KV-Errors-resolve-optimistic](/media/troubleshooting-lock-pic-08.png)

    * TiDB サーバーのログ

        読み書き競合が発生すると、TiDB ログに次のメッセージが表示されます。

        ```log
        [INFO] [coprocessor.go:743] ["[TIME_COP_PROCESS] resp_time:406.038899ms txnStartTS:416643508703592451 region_id:8297 store_addr:10.8.1.208:20160 backoff_ms:255 backoff_types:[txnLockFast,txnLockFast] kv_process_ms:333 scan_total_write:0 scan_processed_write:0 scan_total_data:0 scan_processed_data:0 scan_total_lock:0 scan_processed_lock:0"]
        ```

        * txnStartTS: 読み取り要求を送信しているトランザクションの start_ts。上記のログでは、`416643508703592451` が start_ts です。
        * backoff_types: 読み書き競合が発生し、読み込み要求がバックオフとリトライを行う場合、リトライの種類は `TxnLockFast` です。
        * backoff_ms: 読み取り要求がバックオフとリトライに費やす時間で、単位はミリ秒です。 上記のログでは、読み取り要求が 255 ミリ秒をバックオフとリトライに費やしています。
        * region_id: 読み取り要求のターゲットキーに対応するリージョン ID。

2. TiKV サーバーのログ

    読み書き競合が発生すると、TiKV ログに次のメッセージが表示されます。

    ```log
    [ERROR] [endpoint.rs:454] [error-response] [err=""locked primary_lock:7480000000000004D35F6980000000000000010380000000004C788E0380000000004C0748 lock_version: 411402933858205712 key: 7480000000000004D35F7280000000004C0748 lock_ttl: 3008 txn_size: 1""]
    ```

    このメッセージは、TiDB で読み書き競合が発生していることを示します。 読み取り要求のターゲットキーが別のトランザクションによってロックされています。 ロックは未コミットの楽観的トランザクションおよび Prewrite フェーズ後の未コミットの悲観的トランザクションから来ています。

    * primary_lock: 対象キーが主キーによってロックされていることを示します。
* lock_version： ロックの所有者であるトランザクションの start_ts
* key： ロックがかかっているターゲットキー
* lock_ttl： ロックの TTL（生存期間）
* txn_size： ロックを所有するトランザクションのリージョン内のキー数

解決策:
```
*リード・ライト・コンフリクトが発生すると、自動的にバックオフとリトライがトリガーされます。前述の例のように、Txn1はバックオフとリトライを行います。リトライの最初の時間は10ミリ秒で、最長のリトライ時間は3000ミリ秒であり、合計時間は最大で20000ミリ秒となります。

*指定されたキーに対応する行のテーブルIDと行IDを表示するには、TiDBコントロールのサブコマンド[`decoder`](/tidb-control.md#the-decoder-command)を使用できます。：

    ```sh
    ./tidb-ctl decoder "t\x00\x00\x00\x00\x00\x00\x00\x1c_r\x00\x00\x00\x00\x00\x00\x00\xfa"
    format: table_row
    table_id: -9223372036854775780
    row_id: -9223372036854775558
    ```

### キーがロックされているエラー

トランザクションのPrewriteフェーズでは、TiDBはライト・ライト・コンフリクトの有無をチェックし、ターゲットキーが他のトランザクションによってロックされているかどうかを確認します。キーがロックされている場合、TiKVサーバーは「KeyIsLocked」というエラーを出力します。現在、TiDBおよびTiKVのログにエラーメッセージが出力されることはありません。リード・ライト・コンフリクトと同様に、「KeyIsLocked」が発生した場合、TiDBはトランザクションの自動的なバックオフとリトライを実行します。

GrafanaのTiDBモニタリングで「KeyIsLocked」エラーが発生しているかどうかを確認できます。

TiDBダッシュボードの`KV Errors` パネルには、トランザクションによって引き起こされたライト・ライト・コンフリクトをチェックするために使用できる2つのモニタリングメトリック「Lock Resolve OPS」と「KV Backoff OPS」があります。 `Lock Resolve OPS` の`resolve`アイテムと`KV Backoff OPS` の`txnLock`アイテムには明確な上昇傾向がある場合、「KeyIsLocked」エラーが発生していることがあります。 `resolve` はロックを解除しようとする操作を示し、`txnLock` はライト・コンフリクトを表します。

![KV-backoff-txnLockFast-optimistic-01](/media/troubleshooting-lock-pic-07.png)
![KV-Errors-resolve-optimistic-01](/media/troubleshooting-lock-pic-08.png)

解決策：

* モニタリングで`KV Backoff OPS`で「txnLock」操作がほとんど発生していない場合は、あまり気にする必要はありません。バックグラウンドで自動的にバックオフとリトライが実行されます。単一のリトライにおける最初の時間は100ミリ秒で、最大時間は3000ミリ秒です。
* `KV Backoff OPS`で「txnLock」操作が多すぎる場合は、アプリケーション側でライト・コンフリクトの理由を分析することをお勧めします。
* アプリケーションがライト・ライト・コンフリクトのシナリオである場合は、悲観的トランザクションモードを使用することを強くお勧めします。

### LockNotFound エラー

"TxnLockNotFound"のエラーログは、トランザクションのコミット時間がTTL時間を超過し、トランザクションがコミットしようとする際に、そのロックが他のトランザクションによってロールバックされたことを意味します。TiDBサーバーがトランザクションのコミットをリトライする機能を有効にしている場合、このトランザクションは[tidb_retry_limit](/system-variables.md#tidb_retry_limit)に従って再実行されます。（明示的および暗黙的トランザクションの違いに関する注意事項。）

以下の方法で "LockNotFound"エラーが発生しているかどうかを確認できます。

1. TiDBサーバーのログを表示

    "TxnLockNotFound"エラーが発生した場合、TiDBログメッセージは次のようになります。

    ```log
    [WARN] [session.go:446] ["commit failed"] [conn=149370] ["finished txn"="Txn{state=invalid}"] [error="[kv:6]Error: KV error safe to retry tikv restarts txn: Txn(Mvcc(TxnLockNotFound{ start_ts: 412720515987275779, commit_ts: 412720519984971777, key: [116, 128, 0, 0, 0, 0, 1, 111, 16, 95, 114, 128, 0, 0, 0, 0, 0, 0, 2] })) [try again later]"]
    ```

    * start_ts: `TxnLockNotFound`エラーを出力したトランザクションの`start_ts`。上記のログでは、`412720515987275779`が`start_ts`です。
    * commit_ts: `TxnLockNotFound`エラーを出力したトランザクションの`commit_ts`。上記のログでは、`412720519984971777`が`commit_ts`です。

2. TiKVサーバーのログを表示

   "TxnLockNotFound"エラーが発生した場合、TiKVログメッセージは次のようになります。

    ```log
    Error: KV error safe to retry restarts txn: Txn(Mvcc(TxnLockNotFound)) [ERROR [Kv.rs:708] ["KvService::batch_raft send response fail"] [err=RemoteStoped]
    ```

解決策：

* `start_ts`と`commit_ts`の間隔を確認し、コミット時間がTTL時間を超過していないかどうかを確認します。

    PDコントロールツールを使用してタイムスタンプ間隔を確認します。

    ```shell
    tiup ctl:v<CLUSTER_VERSION> pd tso [start_ts]
    tiup ctl:v<CLUSTER_VERSION> pd tso [commit_ts]
    ```

* トランザクションのパフォーマンスが低下している可能性があるので、書き込みのパフォーマンスが遅いかどうかを確認することをお勧めします。そのため、トランザクションのコミット効率が低下し、ロックが解除されることがあります。

* TiDBトランザクションのリトライが無効になっている場合は、アプリケーション側で例外をキャッチして再試行する必要があります。

## 悲観的ロックコンフリクトのトラブルシューティング

このセクションでは、悲観的トランザクションモードでの一般的なロックコンフリクトの問題の解決策を提供します。

> **注記:**
>
> 悲観的トランザクションモードを設定している場合でも、自動コミットトランザクションは最初に楽観的モードでコミットを試みます。 コンフリクトが発生した場合、トランザクションは自動的に再試行中に悲観的トランザクションモードに切り替わります。

### リード・ライト・コンフリクト

エラーメッセージと解決策は、楽観的ロックコンフリクトの場合の[リード・ライト・コンフリクト](#read-write-conflicts)と同じです。

### 悲観的ロックのリトライ上限が到達しました

トランザクションのコンフリクトが非常に深刻であるか、ライト・コンフリクトが発生すると、楽観的トランザクションは直ちに終了され、悲観的トランザクションはストレージからの最新データを使用してステートメントをリトライします。ロック操作は書き込み操作であるため、処理のプロセスは最初に読み取り、次に書き込みを行う2つのRPCリクエストがあります。トランザクションの途中でライト・コンフリクトが発生した場合、TiDBは再びターゲットのキーをロックしようとします。また、各リトライはTiDBログに出力されます。リトライの回数は[pessimistic-txn.max-retry-count](/tidb-configuration-file.md#max-retry-count)によって決定されます。

悲観的トランザクションモードでは、書き込みのコンフリクトが発生し、リトライ回数が上限に達した場合は、次のキーワードを含むエラーメッセージがTiDBログに出力されます。

```log
err="pessimistic lock retry limit reached"
```

解決策：

* 上記のエラーが頻繁に発生する場合は、アプリケーション側で調整することをお勧めします。
* システム変数[`tidb_pessimistic_txn_fair_locking`](/system-variables.md#tidb_pessimistic_txn_fair_locking-new-in-v700)を有効にすることで、同じ行（同じキー）に対する高い並行ロックを含むビジネスが頻繁にコンフリクトする場合は、吞み込み感増加（平均遅延増加）のコストがかかる場合がありますが、これを試すことができます。新しく展開されたクラスタには、この変数がデフォルトで有効（ON）になっています。

### ロック待機タイムアウトが超過しました

悲観的トランザクションモードでは、トランザクションはお互いのロックを待ちます。ロックを待つタイムアウトは、TiDBの[innodb_lock_wait_timeout](/pessimistic-transaction.md#behaviors)パラメータによって定義されます。これはSQLステートメントレベルの最大待機ロック時間であり、SQLステートメントのロックを期待していますが、ロックが取得されないことを意味します。この時間が経過すると、TiDBは再度ロックを試みることはせず、対応するエラーメッセージをクライアントに返します。

ロック待機タイムアウトが発生した場合、次のエラーメッセージがクライアントに返されます。

```log
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
```

解決策：

* 上記のエラーが頻繁に発生する場合は、アプリケーションロジックを調整することをお勧めします。

### TTLマネージャがタイムアウトしました

トランザクションの実行時間はGC時間制限を超えてはなりません。また、悲観的トランザクションのTTL時間には上限があり、デフォルト値は1時間です。したがって、1時間を超えて実行される悲観的トランザクションはコミットに失敗します。このタイムアウトのしきい値は、TiDBパラメータ[`performance.max-txn-ttl`](https://github.com/pingcap/tidb/blob/master/pkg/config/config.toml.example)によって制御されます。

悲観的トランザクションの実行時間がTTL時間を超過すると、次のエラーメッセージがTiDBログに表示されます。

```log
TTL manager has timed out, pessimistic locks may expire, please commit or rollback this transaction
```

解決策：

* まず、アプリケーションロジックを最適化できるかどうかを確認してください。たとえば、大きなトランザクションはTiDBのトランザクションサイズ制限を引き起こす可能性があり、これを複数の小さなトランザクションに分割できます。
* 関連するパラメータを適切に調整してアプリケーションのトランザクションロジックを満たすようにできます。
### ロックを取得しようとしたときにデッドロックが発生しました

2つ以上のトランザクション間でリソース競合が発生すると、デッドロックが発生します。手動で処理しないとお互いをブロックするトランザクションが正常に実行されず、お互いを永遠に待ち続けます。デッドロックを解消するには、トランザクションのうち1つを手動で終了させて他のトランザクションのリクエストを再開する必要があります。

悲観的なトランザクションがデッドロックに遭遇した場合、そのうち1つのトランザクションを終了する必要があります。クライアントは、MySQLの場合と同様に `Error 1213` エラーを返します。例:

```log
[err="[executor:1213]Deadlock found when trying to get lock; try restarting transaction"]
```

解決策:

* デッドロックの原因を確認するのが難しい場合は、v5.1以降のバージョンでは、`INFORMATION_SCHEMA.DEADLOCKS` や `INFORMATION_SCHEMA.CLUSTER_DEADLOCKS` システムテーブルをクエリしてデッドロック待ちチェーンの情報を取得することをお勧めします。詳細は、[Deadlock errors](#deadlock-errors) セクションと [`DEADLOCKS` table](/information-schema/information-schema-deadlocks.md) ドキュメントを参照してください。
* デッドロックが頻繁に発生する場合は、アプリケーション内のトランザクションクエリロジックを調整して、そのような発生を減らす必要があります。