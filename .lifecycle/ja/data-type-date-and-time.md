---
title: 日付と時刻の型
summary: サポートされている日付と時刻の型について学びます。
aliases: ['/docs/dev/data-type-date-and-time/','/docs/dev/reference/sql/data-types/date-and-time/']
---

# 日付と時刻の型

TiDBはすべてのMySQLの日付と時間のデータ型をサポートしており、時間値を格納するために使用されます。[`DATE`](#date-type)、[`TIME`](#time-type)、[`DATETIME`](#datetime-type)、[`TIMESTAMP`](#timestamp-type)、および[`YEAR`](#year-type)です。詳しくは、[MySQLの日付と時刻のデータ型](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)を参照してください。

それぞれの型には有効な値の範囲があり、無効な値を示すためにゼロ値が使用されます。さらに、`TIMESTAMP`と`DATETIME`の型は自動的に新しい時間値を生成することができます。

日付と時刻の値の型を扱う際には、次の点に注意してください：

+ TiDBは異なるフォーマットを解釈しようとしますが、日付部分は年-月-日の形式（たとえば、'1998-09-04'）である必要があります。月-日-年や日-月-年ではないことに注意してください。
+ 日付の年部分が2桁で指定されている場合、TiDBは[特定のルール]に基づいて変換します。
+ コンテキスト内で数値の値が必要な場合、TiDBは日付や時間の値を自動的に数値型に変換します。例：

    ```sql
    mysql> SELECT NOW(), NOW()+0, NOW(3)+0;
    +---------------------+----------------+--------------------+
    | NOW()               | NOW()+0        | NOW(3)+0           |
    +---------------------+----------------+--------------------+
    | 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
    +---------------------+----------------+--------------------+
    ```

+ TiDBは、無効な値やサポートされている範囲を超える値を、その型のゼロ値に自動的に変換する場合があります。この動作はSQLモードの設定に依存します。例：

    ```sql
    mysql> show create table t1;
    +-------+---------------------------------------------------------------------------------------------------------+
    | Table | Create Table                                                                                            |
    +-------+---------------------------------------------------------------------------------------------------------+
    | t1    | CREATE TABLE `t1` (
      `a` time DEFAULT NULL
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin |
    +-------+---------------------------------------------------------------------------------------------------------+
    1 row in set (0.00 sec)

    mysql> select @@sql_mode;
    +-------------------------------------------------------------------------------------------------------------------------------------------+
    | @@sql_mode                                                                                                                                |
    +-------------------------------------------------------------------------------------------------------------------------------------------+
    | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
    +-------------------------------------------------------------------------------------------------------------------------------------------+
    1 row in set (0.00 sec)

    mysql> insert into t1 values ('2090-11-32:22:33:44');
    ERROR 1292 (22007): Truncated incorrect time value: '2090-11-32:22:33:44'
    mysql> set @@sql_mode='';                                                                                                                                                                                                                     Query OK, 0 rows affected (0.01 sec)

    mysql> insert into t1 values ('2090-11-32:22:33:44');
    Query OK, 1 row affected, 1 warning (0.01 sec)

    mysql> select * from t1;
    +----------+
    | a        |
    +----------+
    | 00:00:00 |
    +----------+
    1 row in set (0.01 sec)
    ```

+ 別のSQLモードを設定することで、TiDBの動作を変更することができます。
+ SQLモード`NO_ZERO_DATE`が有効でない場合、`DATE`および`DATETIME`の列に月や日のゼロ値を含めることができます。たとえば、「2009-00-00」や「2009-01-00」などです。ただし、これらの日付型が関数（例：`DATE_SUB()`、`DATE_ADD()`）で計算される場合、結果は正しくない可能性があります。
+ デフォルトでは、TiDBではSQLモード`NO_ZERO_DATE`が有効になっています。このモードでは、「0000-00-00」などのゼロ値の保存が防がれます。

ゼロ値の異なるタイプに関して、以下の表に示します：

| 日付の型 | "ゼロ"の値 |
| :------   |  :----       |
| DATE      | '0000-00-00' |
| TIME      | '00:00:00'   |
| DATETIME  | '0000-00-00 00:00:00' |
| TIMESTAMP | '0000-00-00 00:00:00' |
| YEAR      | 0000         |

無効な`DATE`、`DATETIME`、`TIMESTAMP`の値は、SQLモードがそのような使用を許可している場合、「0000-00-00」や「0000-00-00 00:00:00」といった対応するゼロ値の型に自動的に変換されます。

## サポートされている型

### `DATE`型

`DATE`には日付部分のみが含まれ、時間部分は含まれません。`YYYY-MM-DD`の形式で表示されます。サポートされる範囲は、'0000-01-01'から'9999-12-31'です：

```sql
DATE
```

### `TIME`型

`TIME`型では、`HH:MM:SS[.fraction]`の形式と、'-838:59:59.000000'から'838:59:59.000000'までの有効な値が範囲となります。`TIME`は、1日の中での時間だけでなく、2つのイベント間の時間間隔を示すためにも使用されます。範囲0から6のオプションの`fsp`値を指定することができます。省略された場合、デフォルトの精度は0です：

```sql
TIME[(fsp)]
```

> **注意：**
>
> `TIME`の略式に注意してください。例えば、'11:12'は '11:12:00'を意味し、'00:11:12'ではありません。ただし、'1112'は'00:11:12'を意味します。これらの違いは、`:`文字の有無によるものです。

### `DATETIME`型

`DATETIME`は日付部分と時間部分の両方を含んでいます。有効な値の範囲は、'0000-01-01 00:00:00.000000'から'9999-12-31 23:59:59.999999'です。

TiDBは、`DATETIME`値を`YYYY-MM-DD HH:MM:SS[.fraction]`形式で表示しますが、`DATETIME`列に値を文字列または数値で割り当てることができます。範囲0から6のオプションのfsp値を指定することができます。省略された場合、デフォルトの精度は0です：

```sql
DATETIME[(fsp)]
```

### `TIMESTAMP`型

`TIMESTAMP`は日付部分と時間部分の両方を含んでいます。有効な値の範囲は、UTC時間での'1970-01-01 00:00:01.000000'から'2038-01-19 03:14:07.999999'です。範囲0から6のオプションのfsp値を指定することができます。省略された場合、デフォルトの精度は0です。

`TIMESTAMP`では、月部分や日部分にゼロを含めることはできません。唯一の例外は、ゼロ値そのもの'0000-00-00 00:00:00'のみです。

```sql
TIMESTAMP[(fsp)]
```

#### タイムゾーンの取り扱い

`TIMESTAMP`を保存する場合、TiDBは`TIMESTAMP`値を現在のタイムゾーンからUTCタイムゾーンに変換します。`TIMESTAMP`を取得する場合、TiDBはUTCタイムゾーンから保存された`TIMESTAMP`値を現在のタイムゾーンに変換します（注意：`DATETIME`はこのように処理されません）。各接続のデフォルトタイムゾーンはサーバーのローカルタイムゾーンであり、環境変数`time_zone`によって変更することができます。

> **警告:**
>
> MySQL同様、`TIMESTAMP`データ型は[2038年問題](https://en.wikipedia.org/wiki/Year_2038_problem)に影響を受けます。2038年を超える値を保存する場合は、代わりに`DATETIME`型を検討してください。

### `YEAR`型

`YEAR`型は、'YYYY'の形式で指定されます。サポートされる値の範囲は、1901から2155、または0000のゼロ値です：

```sql
YEAR[(4)]
```

`YEAR`は次のような形式規則に従います：

+ 4桁の数値は1901から2155の範囲
+ 4桁の文字列は'1901'から'2155'の範囲
+ 1桁または2桁の数値は1から99の範囲。したがって、1-69は2001から2069に変換され、70-99は1970から1999に変換されます
+ 1桁または2桁の文字列は'0'から'99'の範囲
+ 値0は0000として取られます。しかし、文字列'0'または'00'は2000として取られます。

無効な`YEAR`の値は、`NO_ZERO_DATE` SQLモードを使用していない場合、自動的に0000に変換されます。
## `TIMESTAMP`および`DATETIME`の自動初期化および更新

`TIMESTAMP`または`DATETIME`値タイプの列は、自動的に現在の時間で初期化または更新される可能性があります。

テーブル内の`TIMESTAMP`または`DATETIME`値タイプの任意の列について、デフォルト値または自動更新値を現在のタイムスタンプとして設定できます。

これらのプロパティは、列が定義されている際に`DEFAULT CURRENT_TIMESTAMP`および`ON UPDATE CURRENT_TIMESTAMP`を設定することで設定できます。`DEFAULT`は`DEFAULT 0`や`DEFAULT '2000-01-01 00:00:00'`などの特定の値としても設定できます。

```sql
CREATE TABLE t1 (
    ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

`DATETIME`のデフォルト値は、`NOT NULL`と指定されていない限り`NULL`です。後者の場合、デフォルト値が設定されていない場合、デフォルト値は0になります。

```sql
CREATE TABLE t1 (
    dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP,         -- デフォルトはNULL
    dt2 DATETIME NOT NULL ON UPDATE CURRENT_TIMESTAMP -- デフォルトは0
);
```

## 時間値の小数部

`DATETIME`および`TIMESTAMP`値には、最大で6桁までの小数部を含めることができ、マイクロ秒まで正確です。`DATETIME`または`TIMESTAMP`型の任意の列において、小数部は破棄されるのではなく保持されます。小数部を含める場合、値は 'YYYY-MM-DD HH:MM:SS[.fraction]' の形式であり、小数部は000000から999999までの範囲内となります。小数部を残すために、残りの部分から小数部を分離するために小数点が使用されます。

+ `type_name(fsp)`を使用して、小数精度をサポートする列を定義できます。ここで`type_name`は`TIME`、`DATETIME`、または`TIMESTAMP`のいずれかです。例えば、

    ```sql
    CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
    ```

  `fsp`は0から6の範囲内でなければなりません。

  `0`は小数部がないことを意味します。`fsp`が省略された場合、デフォルトは0です。

+ `TIME`、`DATETIME`、または`TIMESTAMP`を挿入する際に小数部を含む場合、小数部の桁数が少なすぎるか、あるいは多すぎる場合、その状況で丸めが必要になるかもしれません。例えば:

    ```sql
    mysql> CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
    Query OK, 0 rows affected (0.33 sec)

    mysql> INSERT INTO fractest VALUES
         > ('17:51:04.777', '2014-09-08 17:51:04.777',   '2014-09-08 17:51:04.777');
    Query OK, 1 row affected (0.03 sec)

    mysql> SELECT * FROM fractest;
    +-------------|------------------------|------------------------+
    | c1          | c2                     | c3                     |
    +-------------|------------------------|------------------------+
    | 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |
    +-------------|------------------------|------------------------+
    1 row in set (0.00 sec)
    ```

## 日付および時間タイプ間の変換

時々、日付および時間タイプ間での変換が必要となります。しかし、一部の変換は情報の損失につながる可能性があります。例えば、`DATE`、`DATETIME`、`TIMESTAMP`の値はそれぞれ独自の範囲を持っています。`TIMESTAMP`は1970年以降のUTC時間またはUTC時間で'2038-01-19 03:14:07'以前である必要があります。このルールによると、'1968-01-01'は`DATE`または`DATETIME`の有効な日付値ですが、これを`TIMESTAMP`に変換すると0になります。

`DATE`の変換:

+ `DATE`を`DATETIME`または`TIMESTAMP`に変換すると、時間部分 '00:00:00' が追加されます。なぜなら`DATE`は時間情報を含んでいないからです。
+ `DATE`を`TIME`に変換すると、結果は '00:00:00' です。

`DATETIME`または`TIMESTAMP`の変換:

+ `DATETIME`または`TIMESTAMP`を`DATE`に変換すると、時間および小数部が破棄されます。例えば、'1999-12-31 23:59:59.499'は'1999-12-31'に変換されます。
+ `DATETIME`または`TIMESTAMP`を`TIME`に変換すると、日付部分が破棄されます。なぜなら`TIME`は日付情報を含んでいないからです。

`TIME`を他の時間および日付フォーマットに変換する際、日付部分は自動的に`CURRENT_DATE()`と指定されます。最終的な変換された結果は、`TIME`と`CURRENT_DATE()`から成る日付となります。これは、値が'00:00:00'から'23:59:59'の範囲外である場合、変換された日付部分が現在の日付を示さないことを意味します。

`TIME`を`DATE`に変換する際も、同様の処理が行われ、時間部分が破棄されます。

`CAST()`関数を使用することで、値を明示的に`DATE`タイプに変換できます。例:

```sql
date_col = CAST(datetime_col AS DATE)
```

`TIME`および`DATETIME`を数値形式に変換する例:

```sql
mysql> SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;
+-----------|-------------|--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------|-------------|--------------+
| 09:28:00  |       92800 |    92800.887 |
+-----------|-------------|--------------+
mysql> SELECT NOW(), NOW()+0, NOW(3)+0;
+---------------------|----------------|--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------|----------------|--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------|----------------|--------------------+
```

## 日付に含まれる二桁の年部分

日付に含まれる二桁の年部分は、実際の年を明示的に示しておらず、曖昧です。

TiDBは、`DATETIME`、`DATE`、および`TIMESTAMP`タイプにおいて、次のルールに従って曖昧性を除去するために次のルールにしたがいます:

- 01から69の値は2001年から2069年の値に変換されます
- 70から99の値は1970年から1999年の値に変換されます

これらのルールは、`YEAR`タイプにも適用されますが、1つの例外があります:

`YEAR(4)`に数字`00`を挿入すると、結果は2000ではなく0000になります。

結果が2000になるようにしたい場合は、値を2000に指定してください。

一部の関数（`MIN()`および`MAX()`など）では、二桁の年部分が正しく計算されない場合があります。これらの関数では、4桁形式がより適しています。