---
title: 精密演算
summary: TiDBの精密演算について学びます。
aliases: ['/docs/dev/functions-and-operators/precision-math/','/docs/dev/reference/sql/functions-and-operators/precision-math/']
---

# 精密演算

TiDBでの精密演算のサポートはMySQLと一貫しています。詳細は、[MySQLの精密演算](https://dev.mysql.com/doc/refman/8.0/en/precision-math.html) を参照してください。

## 数値型

正確値演算の範囲は、正確値データ型（整数およびDECIMAL型）および正確値数値リテラルを含みます。近似値データ型および数値リテラルは浮動小数点数として扱われます。

正確値数値リテラルには整数部または小数部、またはその両方が含まれることがあります。符号を含むことがあります。例：`1`、`.2`、`3.4`、`-5`、`-6.78`、`+9.10`。

近似値数値リテラルは、仮数部および指数部を持つ10のべき乗で表される科学的表記法です。仮数部および指数部のいずれか、または両方に符号を含めることがあります。例：`1.2E3`、`1.2E-3`、`-1.2E3`、`-1.2E-3`。

よく似た2つの数値は異なる扱いを受けることがあります。例えば、`2.34` は正確値（固定小数点）の数値であり、一方 `2.34E0` は近似値（浮動小数点）の数値です。

DECIMALデータ型は固定小数点型であり、計算が正確です。FLOATおよびDOUBLEデータ型は浮動小数点型であり、計算が近似です。

## DECIMALデータ型の特性

ここでは、DECIMALデータ型（およびその同義語）の特性に関する以下のトピックについて説明します：

- 最大桁数
- ストレージ形式
- ストレージ要件

DECIMAL列の宣言構文は `DECIMAL(M,D)` です。引数の値の範囲は次のとおりです：

- M は最大桁数（精度）です。1<= M <= 65。
- D は小数点の右にある桁数（スケール）です。1 <= D <= 30 であり、D は M より大きくすることはできません。

M の最大値 65 は、DECIMALの値に対する計算が最大で 65 桁まで正確であることを意味します。この 65 桁の精度の制限は、正確値数値リテラルにも適用されます。

DECIMAL列の値は、9桁の10進数を4バイトにパックするバイナリ形式で保存されます。各値の整数部と小数部のためのストレージ要件はそれぞれ別々に決定されます。9桁ごとに4バイトが必要であり、残りの桁については4バイトの一部が必要です。残りの桁のためのストレージ要件は以下の表によって与えられます。

| 残りの桁 | バイト数 |
| --- | --- |
| 0   | 0 |
| 1–2 | 1 |
| 3–4 | 2 |
| 5–6 | 3 |
| 7–9 | 4 |

例えば、`DECIMAL(18,9)` 列は小数点の両側に 9桁を持つため、整数部と小数部はそれぞれ 4バイトが必要です。`DECIMAL(20,6)` 列は14桁の整数部と6桁の小数部を持っています。整数部は9桁の場合は 4バイトが、残りの5桁は3バイトが必要です。小数部の6桁は3バイトが必要です。

DECIMAL列には先頭の `+` 文字または `-` 文字または先頭の `0` 桁を保存しません。例えば、`DECIMAL(5,1)` 列に `+0003.1` を挿入すると、`3.1` として保存されます。負の数の場合、リテラル `-` 文字は保存されません。

DECIMAL列は、列の定義が示す範囲よりも大きい値を許可しません。例えば、`DECIMAL(3,0)` 列は `-999` から `999` の範囲をサポートします。`DECIMAL(M,D)` 列は、小数点の左に最大でも `M - D` 桁までの値を許可します。

DECIMALの値の内部フォーマットの詳細については、TiDBソースコードの[`mydecimal.go`](https://github.com/pingcap/tidb/blob/master/pkg/types/mydecimal.go) を参照してください。

## 式の処理

精密演算を含む式について、TiDBは可能な限り正確値数値を使用します。例えば、比較の数値は値が変わらずにそのまま使用されます。厳格なSQLモードでは、列に正確なデータ型を追加する場合、列の範囲内にある場合はその正確な値が挿入されます。取得時には、挿入した値と同じ値が返されます。厳格なSQLモードが無効な場合、TiDBでは挿入時の切り捨てが許可されています。

数値式の処理は、式の値に応じて次のように行われます：

- 式に近似値が含まれる場合、結果は近似値です。TiDBは浮動小数点演算を使用して式を評価します。
- 式に近似値が含まれず、つまり正確値のみが含まれる場合、かつ正確値に小数部が含まれる場合、式はDECIMALの正確な算術を使用して65桁の精度で評価されます。
- それ以外の場合、式には整数値のみが含まれます。式は正確です。TiDBは整数算術を使用して式を評価し、その精度はBIGINT（64ビット）と同じです。

数値式に文字列が含まれる場合、文字列は倍精度の浮動小数点値に変換され、式の結果は近似値です。

数値列への挿入はSQLモードの影響を受けます。以下の議論は、厳格モードと `ERROR_FOR_DIVISION_BY_ZERO` を言及しています。すべての制限を有効にするには、単純に厳格なモード値と `ERROR_FOR_DIVISION_BY_ZERO` の両方を含む `TRADITIONAL` モードを使用できます。

```sql
SET sql_mode = 'TRADITIONAL`;
```

正確な型列（DECIMALまたは整数）に数字が挿入されると、列の範囲内に収まる場合はその正確な値で挿入されます。この数値に対して：

- 小数部の桁数が多すぎる場合、丸めが行われ、警告が生成されます。
- 整数部の桁数が多すぎる場合、大きすぎるため、次のように処理されます：
    - 厳密モードが無効な場合、値は最も近い有効な値に切り捨てられ、警告が生成されます。
    - 厳密モードが有効な場合、オーバーフローエラーが発生します。

数値列に文字列を挿入する場合、TiDBは次のように文字列を数字に変換します：

- 厳格モードでは、数値から始まらない文字列（空の文字列を含む）は数値として使用できません。エラーまたは警告が発生します。
- 数値から始まる文字列は変換できますが、末尾の非数値部分が切り捨てられます。厳格モードでは、切り捨てられた部分に空白以外の何かが含まれている場合には、エラーまたは警告が発生します。

デフォルトでは、0での除算の結果はNULLであり、警告がありません。適切なSQLモードを設定することで、0での除算を制限できます。`ERROR_FOR_DIVISION_BY_ZERO` SQLモードを有効にすると、TiDBは0での除算を次のように処理します：

- 厳密モードでは、挿入および更新が禁止され、エラーが発生します。
- 厳密モードでない場合、警告が発生します。

次のSQL文において：

```sql
INSERT INTO t SET i = 1/0;
```

異なるSQLモードで返される結果は次のとおりです：

| `sql_mode`の値 | 結果 |
| :--- | :--- |
| '' | 警告なし、エラーなし；i はNULLに設定されます。|
| strict | 警告なし、エラーなし；i はNULLに設定されます。 |
| `ERROR_FOR_DIVISION_BY_ZERO` | 警告、エラーなし；i はNULLに設定されます。 |
| strict, `ERROR_FOR_DIVISION_BY_ZERO` | エラー；行が挿入されません。 |

## 丸め動作

`ROUND()` 関数の結果は、その引数が正確または近似値かによって異なります：

- 正確値の場合、 `ROUND()` 関数は "round half up" ルールを使用します。
- 近似値の場合、TiDBの結果はMySQLのものと異なります：

    ```sql
    TiDB > SELECT ROUND(2.5), ROUND(25E-1);
    +------------+--------------+
    | ROUND(2.5) | ROUND(25E-1) |
    +------------+--------------+
    |          3 |            3 |
    +------------+--------------+
    1 row in set (0.00 sec)
    ```

DECIMALまたは整数列への挿入では、丸めは[ゼロから遠くの半分丸め](https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero)が使用されます。

```sql
TiDB > CREATE TABLE t (d DECIMAL(10,0));
Query OK, 0 rows affected (0.01 sec)

TiDB > INSERT INTO t VALUES(2.5),(2.5E0);
Query OK, 2 rows affected, 2 warnings (0.00 sec)

TiDB > SELECT d FROM t;
+------+
| d    |
+------+
|    3 |
|    3 |
+------+
2 rows in set (0.00 sec)
```