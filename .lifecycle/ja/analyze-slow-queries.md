---
title: 遅いクエリの解析
summary: 遅いクエリを特定し、解析する方法について学びます。

# 遅いクエリの解析

遅いクエリの問題に対処するためには、以下の2つの手順を実行する必要があります。

1. 多くのクエリの中から、どのタイプのクエリが遅いのかを特定する。
2. なぜこのタイプのクエリが遅いのかを解析する。

スロークエリログとステートメントサマリーテーブルの機能を使用すれば、簡単に手順1を実行できます。これらの機能は[TiDBダッシュボード](/dashboard/dashboard-intro.md)に統合されており、遅いクエリをブラウザで直接表示することができます。

このドキュメントは、手順2を実行する方法に焦点を当てています。

通常、遅いクエリには次の主な原因があります。

- オプティマイザに関する問題。誤ったインデックスが選択されたり、誤った結合タイプやシーケンスが選択されたりするなどの問題です。
- システムに関する問題。オプティマイザに起因しないすべての問題がシステムに関する問題です。たとえば、ビジーなTiKVインスタンスがリクエストを遅く処理する、古いリージョン情報が遅いクエリを引き起こすなどがあります。

実際の状況では、オプティマイザによってシステムに関する問題が引き起こされることがあります。たとえば、特定のタイプのクエリに対して、オプティマイザがインデックスの代わりにフルテーブルスキャンを使用することがあります。その結果、SQLクエリは多くのリソースを消費し、そのため一部のTiKVインスタンスのCPU使用率が急上昇することがあります。このようにシステムに問題があるように見えますが、本質的にはオプティマイザに問題があります。

システムに問題があるかどうかを特定するのは比較的簡単です。オプティマイザに問題があるかどうかを解析するには、実行計画が合理的かどうかを確定する必要があります。したがって、遅いクエリを解析する際には、次の手順に従うことをお勧めします。

1. クエリのパフォーマンスボトルネック（つまり、クエリプロセスの時間がかかる部分）を特定する。
2. システムに関する問題を解析する：クエリのボトルネックとその時点での監視/ログ情報に基づいて、可能な原因を解析する。
3. オプティマイザに関する問題を解析する：より良い実行計画があるかどうかを解析する。

上記の手順については、以下のセクションで説明します。

## クエリのパフォーマンスボトルネックを特定する

まず、TiDBにおけるクエリ実行プロセスの主要な段階を把握する必要があります。TiDBにおけるクエリ実行の主要な段階は、[TiDBパフォーマンスマップ](/media/performance-map.png)で説明されています。

以下の方法を使用して、実行時間の情報を取得できます。

- [スローログ](/identify-slow-queries.md)。[TiDBダッシュボード](/dashboard/dashboard-overview.md)でスローログを表示することをお勧めします。
- [`EXPLAIN ANALYZE`ステートメント](/sql-statements/sql-statement-explain-analyze.md)。

上記の方法には、次のような違いがあります。

- スローログは、解析から結果の返却までのSQL実行のほぼすべての段階の実行時間を記録し、比較的包括的です（TiDBダッシュボードでスローログを直感的にクエリや解析することができます）。
- `EXPLAIN ANALYZE`を実行することで、実際のSQL実行における各オペレータの時間消費を学ぶことができます。その結果には、実行時間のより詳細な統計が含まれます。

要するに、スローログと`EXPLAIN ANALYZE`ステートメントは、クエリのパフォーマンスのボトルネックがどのコンポーネント（TiDBまたはTiKV）で、実行のどの段階で遅いのかを正確に特定するのに役立ちます。

また、v4.0.3以降では、スローログの`Plan`フィールドにも`EXPLAIN ANALYZE`の結果が含まれるようになりました。そのため、スローログにSQL実行情報をすべて見ることができます。

## システムに関する問題を解析する

システムに関する問題は、SQLステートメントの異なる実行段階に応じて次のタイプに分類できます。

1. データ処理においてTiKVが遅い。たとえば、TiKVコプロセッサーがデータを遅く処理する。
2. 実行においてTiDBが遅い。たとえば、`Join`オペレーターがデータを遅く処理する。
3. その他の主要な段階で遅い。たとえば、タイムスタンプの取得に時間がかかる。

各遅いクエリに対して、まずクエリがどのタイプに属するかを特定し、その後詳細に解析します。

### データ処理においてTiKVが遅い

TiKVがデータ処理において遅い場合、`EXPLAIN ANALYZE`の結果で簡単に特定できます。次の例では、`StreamAgg_8`と`TableFullScan_15`という2つの`TiKVタスク`（`task`列の`cop[tikv]`で示されます）がそれぞれ`170ms`を要して実行されています。`170ms`を差し引いた後、TiDBオペレーターの実行時間は全体の実行時間に対して非常に小さい割合を占めています。これはTiKVがボトルネックであることを示しています。

```sql
+----------------------------+---------+---------+-----------+---------------+------------------------------------------------------------------------------+---------------------------------+-----------+------+
| id                         | estRows | actRows | task      | access object | execution info                                                               | operator info                   | memory    | disk |
+----------------------------+---------+---------+-----------+---------------+------------------------------------------------------------------------------+---------------------------------+-----------+------+
| StreamAgg_16               | 1.00    | 1       | root      |               | time:170.08572ms, loops:2                                                     | funcs:count(Column#5)->Column#3 | 372 Bytes | N/A  |
| └─TableReader_17           | 1.00    | 1       | root      |               | time:170.080369ms, loops:2, rpc num: 1, rpc time:17.023347ms, proc keys:28672 | data:StreamAgg_8                | 202 Bytes | N/A  |
|   └─StreamAgg_8            | 1.00    | 1       | cop[tikv] |               | time:170ms, loops:29                                                          | funcs:count(1)->Column#5        | N/A       | N/A  |
|     └─TableFullScan_15     | 7.00    | 28672   | cop[tikv] | table:t       | time:170ms, loops:29                                                          | keep order:false, stats:pseudo  | N/A       | N/A  |
+----------------------------+---------+---------+-----------+---------------+------------------------------------------------------------------------------+---------------------------------+-----------+------
```

さらに、スローログの`Cop_process`と`Cop_wait`フィールドも解析に役立ちます。次の例では、クエリの合計実行時間は約`180.85ms`で、最大の`Copタスク`は`171ms`を要しています。これは、このクエリのボトルネックがTiKV側にあることを示しています。

各スローログのフィールドの詳細については、[フィールドの説明](/identify-slow-queries.md#fields-description)を参照してください。

```log
# Query_time: 0.18085
...
# Num_cop_tasks: 1
# Cop_process: Avg_time: 170ms P90_time: 170ms Max_time: 170ms Max_addr: 10.6.131.78
# Cop_wait: Avg_time: 1ms P90_time: 1ms Max_time: 1ms Max_Addr: 10.6.131.78
```

TiKVがボトルネックであることを特定した後は、以下のセクションでその原因を特定できます。

#### TiKVインスタンスがビジー

SQLステートメントの実行中、TiDBは複数のTiKVインスタンスからデータを取得する場合があります。あるTiKVインスタンスが遅く応答すると、全体のSQL実行速度が遅くなります。

スローログの`Cop_wait`フィールドを使用して、この原因を特定できます。

```log
# Cop_wait: Avg_time: 1ms P90_time: 2ms Max_time: 110ms Max_Addr: 10.6.131.78
```

上記のログは、`cop-task`が`10.6.131.78`インスタンスに送信されてから実行されるまで`110ms`待機していたことを示しています。このインスタンスがビジーであることが示されています。その時点のCPUモニタリングを確認して、原因を確認できます。

#### 古いキーが多すぎる

TiKVインスタンスには、古いバージョンのキーが多く格納されており、これらのキーをスキャンするためにクリーンアップする必要があります。これが処理速度に影響を与えます。

`Total_keys`および`Processed_keys`を確認してください。これらに大きな差異がある場合、TiKVインスタンスには過去のバージョンのキーが多すぎる可能性があります。

```
...
# Total_keys: 2215187529 Processed_keys: 1108056368
...
```

### その他の主要な段階で遅い

#### タイムスタンプの取得が遅い

スローログの`Wait_TS`と`Query_time`を比較できます。タイムスタンプは予め取得されるため、通常は`Wait_TS`が低いはずです。

```
# Query_time: 0.0300000
...
# Wait_TS: 0.02500000
```

#### 古いリージョン情報

TiDB側のリージョン情報が古くなっている可能性があります。この状況では、TiKVは`regionMiss`エラーを返すことがあります。その後、TiDBはPDから再度リージョン情報を取得し、`Cop_backoff`情報に反映されます。失敗した回数と全体の実行時間の両方が記録されます。

```
# Cop_backoff_regionMiss_total_times: 200 Cop_backoff_regionMiss_total_time: 0.2 Cop_backoff_regionMiss_max_time: 0.2 Cop_backoff_regionMiss_max_addr: 127.0.0.1 Cop_backoff_regionMiss_avg_time: 0.2 Cop_backoff_regionMiss_p90_time: 0.2
```
# Cop_backoff_rpcPD_total_times: 200 Cop_backoff_rpcPD_total_time: 0.2 Cop_backoff_rpcPD_max_time: 0.2 Cop_backoff_rpcPD_max_addr: 127.0.0.1 Cop_backoff_rpcPD_avg_time: 0.2 Cop_backoff_rpcPD_p90_time: 0.2

#### サブクエリは事前に実行される

非相関サブクエリを含む文に対しては、サブクエリ部分が事前に実行されることがあります。例えば、`select * from t1 where a = (select max(a) from t2)` のような場合、最適化段階で `select max(a) from t2` の部分が事前に実行されることがあります。`EXPLAIN ANALYZE` の結果にはこのタイプのサブクエリの実行時間が表示されません。

```sql
mysql> explain analyze select count(*) from t where a=(select max(t1.a) from t t1, t t2 where t1.a=t2.a);
+------------------------------+----------+---------+-----------+---------------+--------------------------+----------------------------------+-----------+------+
| id                           | estRows  | actRows | task      | access object | execution info           | operator info                    | memory    | disk |
+------------------------------+----------+---------+-----------+---------------+--------------------------+----------------------------------+-----------+------+
| StreamAgg_59                 | 1.00     | 1       | root      |               | time:4.69267ms, loops:2  | funcs:count(Column#10)->Column#8 | 372 Bytes | N/A  |
| └─TableReader_60             | 1.00     | 1       | root      |               | time:4.690428ms, loops:2 | data:StreamAgg_48                | 141 Bytes | N/A  |
|   └─StreamAgg_48             | 1.00     |         | cop[tikv] |               | time:0ns, loops:0        | funcs:count(1)->Column#10        | N/A       | N/A  |
|     └─Selection_58           | 16384.00 |         | cop[tikv] |               | time:0ns, loops:0        | eq(test.t.a, 1)                  | N/A       | N/A  |
|       └─TableFullScan_57     | 16384.00 | -1      | cop[tikv] | table:t       | time:0s, loops:0         | keep order:false                 | N/A       | N/A  |
+------------------------------+----------+---------+-----------+---------------+--------------------------+----------------------------------+-----------+------+
5 rows in set (7.77 sec)
```

しかし、このタイプのサブクエリ実行をスローログで特定することができます。

```
# Query_time: 7.770634843
...
# Rewrite_time: 7.765673663 Preproc_subqueries: 1 Preproc_subqueries_time: 7.765231874
```

上記のログレコードから、サブクエリが事前に実行されて `7.76秒` かかっていることがわかります。

### TiDB の実行が遅い

TiDB の実行プランが正しいと仮定して、実行が遅い場合は次のように問題を解決できます。SQL文の `EXPLAIN ANALYZE` の結果に基づいて、パラメータを調整するか、ヒントを使用します。

実行プランが正しくない場合は、[オプティマイザの問題を分析する](#analyze-optimizer-issues) セクションを参照してください。

#### 低い並列度

並列度のオペレータがボトルネックである場合、並列度を調整して実行を高速化できます。例えば:

```sql
mysql> explain analyze select sum(t1.a) from t t1, t t2 where t1.a=t2.a;
+----------------------------------+--------------+-----------+-----------+---------------+-------------------------------------------------------------------------------------+------------------------------------------------+------------------+---------+
| id                               | estRows      | actRows   | task      | access object | execution info                                                                      | operator info                                  | memory           | disk    |
+----------------------------------+--------------+-----------+-----------+---------------+-------------------------------------------------------------------------------------+------------------------------------------------+------------------+---------+
| HashAgg_11                       | 1.00         | 1         | root      |               | time:9.666832189s, loops:2, PartialConcurrency:4, FinalConcurrency:4                | funcs:sum(Column#6)->Column#5                  | 322.125 KB       | N/A     |
| └─Projection_24                  | 268435456.00 | 268435456 | root      |               | time:9.098644711s, loops:262145, Concurrency:4                                      | cast(test.t.a, decimal(65,0) BINARY)->Column#6 | 199 KB           | N/A     |
|   └─HashJoin_14                  | 268435456.00 | 268435456 | root      |               | time:6.616773501s, loops:262145, Concurrency:5, probe collision:0, build:881.404µs  | inner join, equal:[eq(test.t.a, test.t.a)]     | 131.75 KB        | 0 Bytes |
|     ├─TableReader_21(Build)      | 16384.00     | 16384     | root      |               | time:6.553717ms, loops:17                                                           | data:Selection_20                              | 33.6318359375 KB | N/A     |
|     │ └─Selection_20             | 16384.00     |           | cop[tikv] |               | time:0ns, loops:0                                                                   | not(isnull(test.t.a))                          | N/A              | N/A     |
|     │   └─TableFullScan_19       | 16384.00     | -1        | cop[tikv] | table:t2      | time:0s, loops:0                                                                    | keep order:false                               | N/A              | N/A     |
|     └─TableReader_18(Probe)      | 16384.00     | 16384     | root      |               | time:6.880923ms, loops:17                                                           | data:Selection_17                              | 33.6318359375 KB | N/A     |
|       └─Selection_17             | 16384.00     |           | cop[tikv] |               | time:0ns, loops:0                                                                   | not(isnull(test.t.a))                          | N/A              | N/A     |
|         └─TableFullScan_16       | 16384.00     | -1        | cop[tikv] | table:t1      | time:0s, loops:0                                                                    | keep order:false                               | N/A              | N/A     |
+----------------------------------+--------------+-----------+-----------+---------------+-------------------------------------------------------------------------------------+------------------------------------------------+------------------+---------+
9 rows in set (9.67 sec)
```

上記のように、`HashJoin_14` と `Projection_24` が実行時間の大部分を消費しています。並列度を増やすためにSQL変数を使用することで、実行を高速化できます。

すべてのシステム変数については、[system-variables](/system-variables.md) で文書化されています。`HashJoin_14` の並列度を増やすには、`tidb_hash_join_concurrency` システム変数を変更できます。

#### データがディスクにスピルされる

実行中にメモリ制限に達した場合に発生するディスクスピルが実行を遅くする別の原因です。実行プランとスローログでこの原因を特定することができます。

```sql
+-------------------------+-----------+---------+-----------+---------------+------------------------------+----------------------+-----------------------+----------------+
| id                      | estRows   | actRows | task      | access object | execution info               | operator info        | memory                | disk           |
+-------------------------+-----------+---------+-----------+---------------+------------------------------+----------------------+-----------------------+----------------+
| Sort_4                  | 462144.00 | 462144  | root      |               | time:2.02848898s, loops:453  | test.t.a             | 149.68795776367188 MB | 219.3203125 MB |
| └─TableReader_8         | 462144.00 | 462144  | root      |               | time:616.211272ms, loops:453 | data:TableFullScan_7 | 197.49601364135742 MB | N/A            |
|   └─TableFullScan_7     | 462144.00 | -1      | cop[tikv] | table:t       | time:0s, loops:0             | keep order:false     | N/A                   | N/A            |
+-------------------------+-----------+---------+-----------+---------------+------------------------------+----------------------+-----------------------+----------------+
```

```
...
# Disk_max: 229974016
...
```

#### 直積結合のある結合演算

直積結合を含む結合演算は `left child row count * right child row count` と同じ大きなデータ量を生成します。これは非効率であり、避けるべきです。

この種の結合演算は実行プランで `CARTESIAN` とマークされています。例えば:

```sql
mysql> explain select * from t t1, t t2 where t1.a>t2.a;
+------------------------------+-------------+-----------+---------------+---------------------------------------------------------+
| id                           | estRows     | task      | access object | operator info                                           |
+------------------------------+-------------+-----------+---------------+---------------------------------------------------------+
```
```
      | HashJoin_8                   | 99800100.00 | root      |               | CARTESIAN inner join, other cond:gt(test.t.a, test.t.a) |
      | ├─TableReader_15(Build)      | 9990.00     | root      |               | data:Selection_14                                       |
      | │ └─Selection_14             | 9990.00     | cop[tikv] |               | not(isnull(test.t.a))                                   |
      | │   └─TableFullScan_13       | 10000.00    | cop[tikv] | table:t2      | keep order:false, stats:pseudo                          |
      | └─TableReader_12(Probe)      | 9990.00     | root      |               | data:Selection_11                                       |
      |   └─Selection_11             | 9990.00     | cop[tikv] |               | not(isnull(test.t.a))                                   |
      |     └─TableFullScan_10       | 10000.00    | cop[tikv] | table:t1      | keep order:false, stats:pseudo                          |
      +------------------------------+-------------+-----------+---------------+---------------------------------------------------------+
```
## オプティマイザーの問題を分析する

オプティマイザーの問題を分析するには、実行計画が妥当かどうかを判断する必要があります。最適化プロセスと各オペレータについて一定程度の理解が必要です。

以下の例では、テーブルのスキーマが `create table t (id int, a int, b int, c int, primary key(id), key(a), key(b, c))` であるとします。

1. `select * from t`: フィルタ条件がなく、フルテーブルスキャンが実行されます。そのため、データの読み取りには `TableFullScan` オペレータが使用されます。
2. `select a from t where a=2`: フィルタ条件があり、インデックスカラムのみが読み取られるため、データの読み取りには `IndexReader` オペレータが使用されます。
3. `select * from t where a=2`: `a` に対するフィルタ条件がありますが、`a` インデックスがデータを完全にカバーしていないため、`IndexLookup` オペレータが使用されます。
4. `select b from t where c=3`: プレフィックス条件がないため、複数列インデックスを使用することができません。そのため、`IndexFullScan` が使用されます。
5. ...

上記の例は、データの読み取りに使用されるオペレータです。その他のオペレータについては、[TiDB実行計画の理解](/explain-overview.md)を参照してください。

また、[SQLチューニング概要](/sql-tuning-overview.md)を読むことで、TiDBオプティマイザーの理解を深め、実行計画が妥当かどうかを判断することができます。

オプティマイザーの問題のほとんどは、[SQLチューニング概要](/sql-tuning-overview.md)で説明されています。解決策については、以下のドキュメントを参照してください。

1. [誤ったインデックスの解決策](/wrong-index-solution.md)
2. [結合順序が間違っている](/join-reorder.md)
3. [式がプッシュダウンされていない](/blocklist-control-plan.md)
```