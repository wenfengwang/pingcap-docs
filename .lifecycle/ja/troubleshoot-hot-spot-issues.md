---
title: ホットスポットのトラブルシューティング
summary: TiDB での読み込みおよび書き込みのホットスポット問題を特定し、解決する方法について説明します。

# ホットスポットのトラブルシューティング

本書では、読み込みおよび書き込みのホットスポット問題を特定し、解決する方法について説明します。

TiDBは分散データベースであり、アプリケーション負荷をできるだけ均等に異なる計算またはストレージノードに分散させ、サーバーリソースをより効果的に活用するための負荷分散メカニズムを備えています。しかし、特定のシナリオでは、一部のアプリケーション負荷を十分に分散できず、パフォーマンスに影響を与え、高負荷の単一箇所、つまりホットスポットが形成されることがあります。

TiDBではホットスポットのトラブルシューティング、解決、または回避の完全なソリューションを提供しています。ホットスポットの負荷を均等に分散することで、全体的なパフォーマンスが向上し、QPSが向上し、レイテンシが低減します。

## 一般的なホットスポット

このセクションでは、TiDBのエンコードルール、テーブルのホットスポット、およびインデックスのホットスポットについて説明します。

### TiDBのエンコードルール

TiDBは各テーブルにTableID、各インデックスにIndexID、および各行にRowIDを割り当てます。デフォルトでは、テーブルが整数の主キーを使用する場合、主キーの値はRowIDとして扱われます。これらのIDのうち、TableIDはクラスタ全体でユニークであり、IndexIDおよびRowIDはテーブル内でユニークです。これらのIDの型はすべてint64です。

各データ行は、次のルールに従ってキーと値のペアとしてエンコードされます:

```
Key: tablePrefix{tableID}_recordPrefixSep{rowID}
Value: [col1, col2, col3, col4] 
```

キーのtablePrefixおよびrecordPrefixSepは、KVスペースの他のデータと区別するために使用される特定の文字列定数です。

インデックスデータの場合、キーと値のペアは次のルールに従ってエンコードされます:

```
Key: tablePrefix{tableID}_indexPrefixSep{indexID}_indexedColumnsValue
Value: rowID
```

インデックスデータには、ユニークインデックスと非ユニークインデックスの2種類があります。

- ユニークインデックスの場合、上記のコーディングルールに従うことができます。
- 非ユニークインデックスの場合、このエンコードを通じて一意のキーを構築することはできません。なぜなら、同じインデックスの`tablePrefix{tableID}_indexPrefixSep{indexID}`が同じであり、複数行の`ColumnsValue`が同じ場合があるためです。非ユニークインデックスに対するエンコードルールは次のとおりです:

    ```
    Key: tablePrefix{tableID}_indexPrefixSep{indexID}_indexedColumnsValue_rowID
    Value: null
    ```

### テーブルのホットスポット

TiDBのエンコードルールに従うと、同じテーブルのデータはTableIDの先頭にプレフィックスが付いた範囲にあり、データはRowID値の順に配置されます。テーブルの挿入時にRowID値が増加すると、挿入された行は末尾にのみ追加されます。領域はあるサイズに達した後に分割され、その後も範囲の末尾にのみ追加することができます。INSERT操作は1つのリージョンでのみ実行でき、これによりホットスポットが形成されます。

一般的な自動増分主キーは順次増加します。主キーが整数型の場合、通常、主キーの値がRowIDとして使用されます。この場合、RowIDは順次増加し、大量のINSERT操作が存在するとテーブルの書き込みホットスポットが形成されます。

また、TiDBのRowIDはデフォルトで順次自動増分します。主キーが整数型ではない場合、書き込みホットスポットの問題に遭遇する可能性があります。

また、データの書き込み（新しく作成されたテーブルやパーティションでのホットスポット）や読み込み（読み取り専用のシナリオでの定期的な読み込みホットスポット）の過程でホットスポットが発生する場合、テーブル属性を使用してリージョンのマージ動作を制御することができます。詳細については、[テーブル属性を使用してリージョンのマージ動作を制御する](/table-attributes.md#control-the-region-merge-behavior-using-table-attributes)を参照してください。

### インデックスのホットスポット

インデックスのホットスポットは、テーブルのホットスポットに類似しています。一般的なインデックスのホットスポットは、時系列順に単調に増加するフィールドや大量の重複値を持つ`INSERT`シナリオで発生します。

## ホットスポットの問題を特定する

パフォーマンスの問題は必ずしもホットスポットによるものではなく、複数の要因によるものである場合があります。問題をトラブルシューティングする前に、それがホットスポットに関連しているかどうかを確認してください。

- 書き込みのホットスポットを判断するには、**TiKV-Trouble-Shooting**モニタリングパネルで**Hot Write**を開いて、任意のTiKVノードのRaftstore CPUメトリック値が他のノードよりも著しく高いかどうかを確認してください。

- 読み込みのホットスポットを判断するには、**TiKV-Details**モニタリングパネルで**Thread_CPU**を開いて、任意のTiKVノードのcoprocessor CPUメトリック値が特に高いかどうかを確認してください。

### TiDBダッシュボードを使用してホットスポットテーブルを特定する

[**TiDBダッシュボード**](/dashboard/dashboard-intro.md)の**Key Visualizer**機能を使用すると、ホットスポットトラブルシューティングの範囲をテーブルレベルに絞り込むことができます。次に示すのは**Key Visualizer**が表示するサーマルダイアグラムの例です。グラフの横軸は時間、縦軸は様々なテーブルとインデックスです。色が明るいほど負荷が大きいです。ツールバーで読み込みまたは書き込みフローを切り替えることができます。

![ダッシュボード例1](/media/troubleshoot-hot-spot-issues-1.png)

次の表またはインデックスフローグラフには、明るい対角線（斜め上または下）が表示されることがあります。書き込みは末尾にのみ表示されるため、テーブルリージョンが増加すると、はしご状に表示されます。これは、このテーブルに書き込みホットスポットが存在することを示します:

![ダッシュボード例2](/media/troubleshoot-hot-spot-issues-2.png)

読み込みのホットスポットの場合、一般的にサーマルダイアグラムに明るい水平線が表示されます。これは通常、多くのアクセスを持つ小さいテーブルによって引き起こされます:

![ダッシュボード例3](/media/troubleshoot-hot-spot-issues-3.png)

明るいブロックの上にカーソルを合わせると、どのテーブルまたはインデックスが重い負荷を持つかが表示されます。例:

![ダッシュボード例4](/media/troubleshoot-hot-spot-issues-4.png)

## `SHARD_ROW_ID_BITS`を使用してホットスポットを処理する

非クラスタ化主キーまたはプライマリキーのないテーブルの場合、TiDBは暗黙の自動増分RowIDを使用します。大量の`INSERT`操作が存在する場合、データは1つのリージョンに書き込まれ、書き込みホットスポットが発生します。

[`SHARD_ROW_ID_BITS`](/shard-row-id-bits.md)を設定することで、RowIDが散らばり、複数のリージョンに書き込まれるため、書き込みホットスポット問題を緩和することができます。

```
SHARD_ROW_ID_BITS = 4 # 16個のシャードを表す。
SHARD_ROW_ID_BITS = 6 # 64個のシャードを表す。
SHARD_ROW_ID_BITS = 0 # デフォルトの1つのシャードを表す。
```

ステートメントの例:

{{< copyable "sql" >}}

```sql
CREATE TABLE: CREATE TABLE t (c int) SHARD_ROW_ID_BITS = 4;
ALTER TABLE: ALTER TABLE t SHARD_ROW_ID_BITS = 4;
```

`SHARD_ROW_ID_BITS`の値は動的に変更できます。変更後の値は新しく書き込まれるデータにのみ効果があります。

`CLUSTERED`型のプライマリキーを持つテーブルの場合、TiDBはテーブルのプライマリキーをRowIDとして使用します。この場合、`SHARD_ROW_ID_BITS`オプションは使用できません。なぜなら、RowIDの生成ルールが変わるためです。`NONCLUSTERED`型のプライマリキーを持つテーブルの場合、TiDBは自動的に割り当てられた64ビット整数をRowIDとして使用します。この場合、`SHARD_ROW_ID_BITS`機能を使用できます。`CLUSTERED`型のプライマリキーについての詳細は、[クラスタ化インデックス](/clustered-indexes.md)を参照してください。

次の2つの負荷ダイアグラムは、プライマリキーのない2つのテーブルが`SHARD_ROW_ID_BITS`を使用してホットスポットを散らした場合の例を示しています。最初のダイアグラムはホットスポットを散らす前の状況を示し、2番目のダイアグラムはホットスポットを散らした後の状況を示しています。

![ダッシュボード例5](/media/troubleshoot-hot-spot-issues-5.png)

![ダッシュボード例6](/media/troubleshoot-hot-spot-issues-6.png)

上記の負荷ダイアグラムから、`SHARD_ROW_ID_BITS`を設定する前は、負荷ホットスポットが1つのリージョンに集中していることがわかります。`SHARD_ROW_ID_BITS`を設定した後は、負荷ホットスポットが散らばっていることがわかります。

## `AUTO_RANDOM`を使用して自動増分主キーホットスポットテーブルを処理する

自動増分主キーによって引き起こされる書き込みのホットスポットを解決するには、自動増分主キーを持つホットスポットテーブルに`AUTO_RANDOM`を使用します。

この機能を有効にすると、TiDBはランダムに分布し、使用され尽くすまで繰り返さないプライマリキーを生成して、書き込みホットスポットを散らす目的を達成します。

TiDBによって生成されるプライマリキーはもはや自動増分のプライマリキーではなく、`LAST_INSERT_ID()`を使用して前回割り当てられたプライマリキーの値を取得することができます。

この機能を使用するには、`CREATE TABLE`文で`AUTO_INCREMENT`を`AUTO_RANDOM`に変更します。この機能は、プライマリキーが一意である必要があるだけでよい非アプリケーションシナリオに適しています。

例:

{{< copyable "sql" >}}

```sql
CREATE TABLE t (a BIGINT PRIMARY KEY AUTO_RANDOM, b varchar(255));
INSERT INTO t (b) VALUES ("foo");
SELECT * FROM t;
```

```sql
+------------+---+
| a          | b |
+------------+---+
```sql
SELECT LAST_INSERT_ID();
```
```sql
+------------------+
| LAST_INSERT_ID() |
+------------------+
| 1073741825       |
+------------------+
```

次の2つのロードダイアグラムは、`AUTO_INCREMENT`を`AUTO_RANDOM`に変更してホットスポットを分散させる前後の状況を示しています。最初のものは`AUTO_INCREMENT`を使用し、2番目のものは`AUTO_RANDOM`を使用しています。

![ダッシュボードの例7](/media/troubleshoot-hot-spot-issues-7.png)

![ダッシュボードの例8](/media/troubleshoot-hot-spot-issues-8.png)

上記のロードダイアグラムに示すように、`AUTO_RANDOM`を`AUTO_INCREMENT`の代わりに使用することで、ホットスポットを効果的に分散させることができます。

詳細については、[AUTO_RANDOM](/auto-random.md)を参照してください。

## 小さなテーブルのホットスポットの最適化

TiDBのCoprocessor Cache機能は、計算結果キャッシュをプッシュダウンするサポートを提供しています。この機能を有効にした後、TiDBはTiKVにプッシュダウンされる計算結果をキャッシュします。この機能は、小さなテーブルの読み取りホットスポットに適しています。

詳細については、[Coprocessor Cache](/coprocessor-cache.md)を参照してください。

**関連情報:**

- [高並列書き込みのベストプラクティス](/best-practices/high-concurrency-best-practices.md)
- [リージョンの分割](/sql-statements/sql-statement-split-region.md)

## 読み取りホットスポットの分散

読み取りホットスポットのシナリオでは、ホットスポットのTiKVノードは読み取りリクエストを時間内に処理できず、読み取りリクエストがキューイングされています。ただし、この時点ではすべてのTiKVリソースが枯渇しているわけではありません。レイテンシを低減するために、TiDB v7.1.0ではロードベースのレプリカ読み取り機能が導入され、ホットスポットのTiKVノードでのキューイングをせずに、他のTiKVノードからデータを読み取ることができます。[`tidb_load_based_replica_read_threshold`](/system-variables.md#tidb_load_based_replica_read_threshold-new-in-v700)システム変数を使用して、読み取りリクエストのキュー長を制御することができます。リーダーノードの見積もられるキュー時間がこの閾値を超えると、TiDBはフォロワーノードからデータを読み取ることを優先します。この機能により、読み取りホットスポットのシナリオでの読み取りスループットは、読み取りホットスポットを分散させない場合と比較して70%から200%向上することができます。