---
title: パフォーマンスチューニングの概要
summary: このドキュメントでは、ユーザの応答時間、スループット、データベース時間など、パフォーマンスチューニングの基本的な概念を紹介し、パフォーマンスチューニングの一般的なプロセスも提供します。
---

# TiDB パフォーマンスチューニングの概要

このドキュメントでは、ユーザの応答時間、スループット、データベース時間など、パフォーマンスチューニングの基本的な概念を紹介し、パフォーマンスチューニングの一般的なプロセスも提供します。

## ユーザの応答時間とデータベース時間

### ユーザの応答時間

ユーザの応答時間は、アプリケーションがユーザの要求の結果を返すまでにかかる時間を示します。以下のシーケンシャルタイミングダイアグラムから分かるように、典型的なユーザのリクエストにかかる時間には以下の要素が含まれます。

- ユーザとアプリケーション間のネットワークの遅延
- アプリケーションの処理時間
- アプリケーションとデータベース間のやり取り中のネットワークの遅延
- データベースのサービス時間

ユーザの応答時間は、ネットワークの遅延や帯域幅、同時ユーザの数やリクエストの種類、サーバの CPU 使用率や I/O のリソース使用状況など、リクエストチェーン上のさまざまなサブシステムによって影響を受けます。システム全体を効果的に最適化するためには、まずユーザの応答時間のボトルネックを特定する必要があります。

指定された時間範囲（`ΔT`）内での合計ユーザの応答時間を求めるためには、次の式を使用できます。

`ΔT` 内の合計ユーザの応答時間 = 平均 TPS（秒間トランザクション数）x 平均ユーザの応答時間 x `ΔT`。

![user_response_time](/media/performance/user_response_time_en.png)

### データベース時間

データベース時間は、データベースが提供する合計サービス時間を示します。`ΔT` のデータベース時間は、データベースがすべてのアプリケーションリクエストを同時に処理するためにかかる時間の合計です。

データベース時間を取得するには、次のいずれかの方法を使用できます。

- 方法 1: 平均クエリの所要時間に QPS と ΔT を掛ける、つまり `ΔT` の DB 時間 = QPS × 平均所要時間 × ΔT
- 方法 2: 平均アクティブセッション数に ΔT を掛ける、つまり `ΔT` の DB 時間 = 平均アクティブコネクション数 × ΔT
- 方法 3: TiDB の内部 Prometheus メトリック `tidb_server_tokens` を基に時間を計算する、つまり `ΔT DB 時間 = rate(tidb_server_tokens) × ΔT`

## ユーザの応答時間とシステムのスループットの関係

ユーザの応答時間は、ユーザリクエストを完了するために必要なサービス時間、待ち時間、および並行して待機する時間から構成されます。

```
ユーザの応答時間 = サービス時間 + 待ち時間 + 一貫性遅延
```

- サービス時間：リクエストを処理する際にシステムが特定のリソースに消費する時間。たとえば、データベースが SQL リクエストを完了するために消費する CPU 時間など。
- 待ち時間：リクエストを処理するために、システムが特定のリソースのサービスを待ち状態で待つ時間。
- 一貫性遅延：リクエストを処理する際にシステムが他の並行タスクと通信し協調するための時間。これにより、リクエストが共有リソースにアクセスできるようになります。

システムのスループットは、システムが秒間で完了できるリクエスト数を示します。ユーザの応答時間とスループットは通常、互いに逆の関係にあります。スループットが増加すると、システムのリソース利用率とリクエストされたサービスの待ち時間も増加します。一定の転換点を超えると、待ち時間は急激に増加します。

たとえば、OLTP ロードを実行しているデータベースシステムでは、CPU 使用率が 65% を超えると、CPU の待ち時間が著しく増加します。これは、システムの同時リクエストが完全に独立していないことを意味します。つまり、これらのリクエストは共有リソースに対して協力し競合する可能性があります。たとえば、異なるユーザのリクエストは同じデータに排他的なロック操作を実行するかもしれません。リソース使用率が上がると、待ち時間とスケジューリングの待ち時間も増加し、共有リソースを間に合わせることができず、他のタスクによる共有リソースの待機時間が延長されることになります。

## パフォーマンスチューニングのプロセス

パフォーマンスチューニングのプロセスは次の 6 つのステップから構成されます。

1. チューニング目標を定義する。
2. パフォーマンスのベースラインを確立する。
3. ユーザの応答時間のボトルネックを特定する。
4. チューニングの解決策を提案し、各解決策の利点、リスク、コストを評価する。
5. チューニングの解決策を実装する。
6. チューニングの結果を評価する。

パフォーマンスチューニングプロジェクトのチューニング目標を達成するには、通常、このドキュメントのステップ 2 からステップ 6 を複数回繰り返す必要があります。

### ステップ 1. チューニング目標を定義する

システムの種類に応じて、チューニング目標も異なります。たとえば、金融の中核 OLTP システムの場合、チューニングの目標はトランザクションの長尾遅延を減らすことである場合があります。金融の精算システムの場合、チューニングの目標はハードウェアリソースの効果的な利用とバッチ精算タスクの時間の短縮かもしれません。

良いチューニングの目標は容易に数量化できるものであるべきです。たとえば:

- 良いチューニングの目標: トランスファートトランザクションの p99 レイテンシは、朝 9 時から 10 時のピーク業務時間帯に 200 ミリ秒未満である必要があります。
- 悪いチューニングの目標: システムが遅すぎて応答しないので、最適化する必要があります。

明確なチューニング目標を定義することで、以降のパフォーマンスチューニングステップをガイドするのに役立ちます。

### ステップ 2. パフォーマンスのベースラインを確立する

効率的なパフォーマンスチューニングを行うためには、パフォーマンスのベースラインを確立するために現在のパフォーマンスデータを取得する必要があります。通常、取得するパフォーマンスデータは次のようなものです。

- アプリケーションの平均ユーザの応答時間、長尾値、およびスループットなどのパフォーマンスデータ
- データベースのパフォーマンスデータ、たとえばデータベースの時間、クエリの待ち時間、QPS など

  TiDB では、[遅いクエリログ](/identify-slow-queries.md)、[トップ SQL](/dashboard/top-sql.md)、[連続パフォーマンスプロファイリング](/dashboard/continuous-profiling.md)、[トラフィックビジュアライザ](/dashboard/dashboard-key-visualizer.md) など、さまざまな観点でパフォーマンスデータを詳細に測定し保存しています。さらに、Prometheus に保存されたタイミングメトリックデータの履歴的なバックトラッキングと比較を行うこともできます。

- CPU、IO、ネットワークなどのリソース利用状況
- アプリケーション構成、データベース構成、オペレーティングシステム構成などの設定情報

### ステップ 3. ユーザの応答時間のボトルネックを特定する

パフォーマンスベースラインのデータから、ユーザの応答時間のボトルネックを特定または推定します。

アプリケーションは通常、ユーザリクエストの完全なチェーンを計測して記録しませんので、アプリケーションを通して上から下まで効果的にユーザの応答時間を分解することはできません。

これに対して、データベースはクエリの待ち時間やスループットなどのパフォーマンスメトリックスの完全な記録を持っています。データベース時間に基づいて、ユーザの応答時間のボトルネックがデータベースにあるかどうかを判断できます。

- データベースにボトルネックがない場合、データベース以外で収集されたリソース利用状況に依存するか、アプリケーションをプロファイリングしてデータベース以外のボトルネックを特定する必要があります。一般的なシナリオには、アプリケーションやプロキシサーバのリソース不足、アプリケーション内のシリアルポイントによるハードウェアリソースの十分な使用不足などがあります。
- データベースにボトルネックがある場合、包括的なチューニングツールを使用してデータベースのパフォーマンスを分析し診断することができます。一般的なシナリオには、遅い SQL の存在、アプリケーションによるデータベースの不合理な使用、およびデータベース内の読み取り/書き込みのホットスポットの存在などがあります。

解析および診断の方法とツールについての詳細は、[パフォーマンス分析とチューニング](/performance-tuning-methods.md)を参照してください。

### ステップ 4. チューニングの解決策を提案し、各解決策の利点、リスク、コストを評価する

パフォーマンス分析を通じてシステムのボトルネックを特定した後、現実の状況に基づいて、コスト効果が高く、リスクが低く、最大の利益をもたらすチューニング解決策を提案することができます。

[Amdahl の法則](https://ja.wikipedia.org/wiki/Amdahl%E3%81%AE%E6%B3%95%E5%89%87)によれば、パフォーマンスチューニングによる最大の利益は、全体システムの最適化部分の割合に依存します。したがって、パフォーマンスデータに基づいてシステムのボトルネックとそれに対応する割合を特定し、ボトルネックが解決または最適化された後の利益を予測する必要があります。

ただし、最大の潜在的な利益をもたらす解決策であっても、その解決策のリスクやコストを評価する必要があります。たとえば:

- リソースが過剰なシステムに対するもっとも直接的なチューニング目標の解決策は、その容量を拡張することですが、実際の運用では、拡張解決策は採用するにはコストが高すぎる場合があります。
- ビジネスモジュールの遅いクエリが全体モジュールの応答を遅くしている場合、データベースの新しいバージョンにアップグレードすることで遅いクエリの問題を解決できますが、これはこの問題を抱えていないモジュールにも影響を与える可能性があります。したがって、この解決策には潜在的に高いリスクがある可能性があります。低リスクの解決策は、データベースバージョンのアップグレードをスキップし、現在のデータベースバージョンに対して既存の遅いクエリを再作成することです。

### ステップ 5. チューニングの解決策を実装する

利点、リスク、コストを考慮して、実装するための 1 つ以上のチューニング解決策を選択します。実装プロセスでは、本番システムへの変更に備え、変更内容を詳細に記録する必要があります。

リスクの軽減とチューニング解決策の利益の検証のためには、テストおよびステージング環境の両方での変更の検証と完全な回帰テストを実施することをお勧めします。たとえば、遅いクエリの選択されたチューニング解決策が、クエリのアクセス経路の最適化のために新しいインデックスを作成することである場合、新しいインデックスが既存のデータ挿入ワークロードに明らかな書き込みホットスポットを導入せず、他のモジュールの処理速度を遅くしないことを確認する必要があります。

### ステップ 6. チューニングの結果を評価する

チューニング解決策を適用した後、結果を評価する必要があります。

- チューニング目標が達成された場合、チューニングプロジェクト全体が成功裏に完了します。
- チューニング目標が達成されなかった場合、本文書のステップ 2 からステップ 6 を再度繰り返してチューニング目標が達成されるまで繰り返す必要があります。
```
After reaching your tuning objectives, you might need to further plan your system capacity to meet your business growth.
```

```
チューニング目標を達成した後、ビジネスの成長に対応するためにシステムの容量をさらに計画する必要があるかもしれません。
```