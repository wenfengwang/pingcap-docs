---
title: 非トランザクショナル DML ステートメント
summary: TiDB での非トランザクショナル DML ステートメントについて学びます。原子性と分離性を犠牲にして、DML ステートメントは複数のステートメントに分割され、順次実行されることで、バッチデータ処理シナリオにおいて安定性と利用の容易さが向上します。

# 非トランザクショナル DML ステートメント

この文書は、TiDB における非トランザクショナル DML ステートメントの使用シナリオ、使用方法、制限について説明しています。さらに、実装原理や一般的な問題についても説明されています。

非トランザクショナル DML ステートメントは、複数の SQL ステートメント（つまり、複数のバッチ）に分割され、順次実行される DML ステートメントです。これにより、トランザクショナルな原子性と分離性を犠牲にして、バッチデータ処理においてパフォーマンスと利用の容易さが向上します。

通常、メモリを消費するトランザクションは、トランザクションのサイズ制限をバイパスするために複数の SQL ステートメントに分割する必要があります。非トランザクショナル DML ステートメントは、このプロセスを TiDB カーネルに統合して、同じ効果を実現します。SQL ステートメントを分割してその効果を理解するには、`DRY RUN` 構文を使用して分割されたステートメントをプレビューできます。

非トランザクショナル DML ステートメントには、次のものが含まれます：

- `INSERT INTO ... SELECT`
- `REPLACE INTO .. SELECT`
- `UPDATE`
- `DELETE`

詳細な構文については、[`BATCH`](/sql-statements/sql-statement-batch.md) を参照してください。

> **注意:**
>
> - 非トランザクショナル DML ステートメントは、ステートメントの原子性と分離性を保証せず、元の DML ステートメントと等価ではありません。
> - DML ステートメントが非トランザクショナルな DML ステートメントに書き換えられた後、その動作が元のステートメントと一貫しているとは仮定できません。
> - 非トランザクショナル DML を使用する前に、分割されたステートメントが互いに影響を与えるかどうかを分析する必要があります。

## 使用シナリオ

大規模なデータ処理のシナリオでは、大規模なデータバッチで同じ操作を行う必要があることがよくあります。単一の SQL ステートメントを使用して操作を実行すると、トランザクションサイズが制限を超え、実行パフォーマンスに影響を与える可能性があります。

バッチデータ処理には、オンラインアプリケーションの操作と時間またはデータが重複しない場合がよくあります。同時実行操作が存在しない場合、隔離性（ACID の I）は不要です。大量のデータ操作が冪等であるか、リトライしやすいのであれば、原子性も不要です。データ隔離や原子性が必要でない場合は、非トランザクショナル DML ステートメントを検討できます。

非トランザクショナル DML ステートメントは、特定のシナリオにおける大規模なトランザクションサイズの制限をバイパスするために使用されます。1 つのステートメントで、トランザクションを手動で分割する必要があるタスクを完了し、実行効率が高く、リソース消費が少ないです。

たとえば、期限切れのデータを削除する場合、期限切れのデータにアクセスするアプリケーションがないことを確認すれば、非トランザクショナル DML ステートメントを使用して `DELETE` のパフォーマンスを向上させることができます。

## 前提条件

非トランザクショナル DML ステートメントを使用する前に、次の条件を満たしていることを確認してください：

- ステートメントは原子性を必要とせず、実行結果において一部の行が変更され、その他の行が変更されないことを許可します。
- ステートメントが冪等であり、またはエラーメッセージに基づいて一部のデータをリトライする準備ができています。システム変数が `tidb_redact_log = 1` および `tidb_nontransactional_ignore_error = 1` に設定されている場合、このステートメントは冪等でなければなりません。それ以外の場合、ステートメントが一部失敗した場合、失敗した部分を正確に特定できません。
- 操作対象のデータに他の並行して書き込む操作がないこと、つまり、同時に他のステートメントによって更新されていないことを確認してください。そうでない場合、欠落した書き込み、誤った書き込み、および同じ行の複数回の変更など、予期しない結果が発生する可能性があります。
- ステートメントは、ステートメント自体によって読み取られるデータを変更しないことを確認してください。それ以外の場合、次のバッチは前のバッチによって書き込まれたデータを読み取り、予期しない結果を簡単に引き起こす可能性があります。

    - 非トランザクショナル `INSERT INTO ... SELECT` ステートメント内で同じテーブルを選択および変更する際に、シャード列を変更しないようにしてください。さもないと、複数のバッチが同じ行を読み取り、データを複数回挿入する可能性があります：
        - `BATCH ON test.t.id LIMIT 10000 INSERT INTO t SELECT id+1, value FROM t;` を使用しないでください。
        - `BATCH ON test.t.id LIMIT 10000 INSERT INTO t SELECT id, value FROM t;` を使用することをお勧めします。
        - シャード列 `id` が `AUTO_INCREMENT` 属性を持っている場合、`BATCH ON test.t.id LIMIT 10000 INSERT INTO t(value) SELECT value FROM t;` を使用することをお勧めします。
    - 非トランザクショナル `UPDATE`、`INSERT ... ON DUPLICATE KEY UPDATE`、または `REPLACE INTO` ステートメントでシャード列を更新しないでください：
        - たとえば、非トランザクショナル `UPDATE` ステートメントでは、分割された SQL ステートメントは順番に実行されます。前のバッチの変更は、前のバッチがコミットされた後に次のバッチによって読み取られるため、同じ行のデータが複数回変更されます。
        - これらのステートメントは `BATCH ON test.t.id LIMIT 10000 UPDATE t SET test.t.id = test.t.id-1;` をサポートしていません。
        - `BATCH ON test.t.id LIMIT 1 INSERT INTO t SELECT id+1, value FROM t ON DUPLICATE KEY UPDATE id = id + 1;` を使用することはお勧めしません。
    - シャード列を結合キーとして使用しないでください。たとえば、次の例では、シャード列 `test.t.id` を結合キーとして使用することで、非トランザクショナル `UPDATE` ステートメントが同じ行に複数回変更されることがあります：

        ```sql
        CREATE TABLE t(id int, v int, key(id));
        CREATE TABLE t2(id int, v int, key(id));
        INSERT INTO t VALUES (1, 1), (2, 2), (3, 3);
        INSERT INTO t2 VALUES (1, 1), (2, 2), (4, 4);
        BATCH ON test.t.id LIMIT 1 UPDATE t JOIN t2 ON t.id = t2.id SET t2.id = t2.id+1;
        SELECT * FROM t2; -- (4, 1) (4, 2) (4, 4)
        ```

- ステートメントが [制限事項](#restrictions) を満たしていることを確認してください。
- この DML ステートメントによって読み取られるまたは書き込まれるテーブルに対して、同時に DDL 操作を実行しないことがお勧めされます。

> **警告:**
>
> `tidb_redact_log` および `tidb_nontransactional_ignore_error` が同時に有効になっている場合、各バッチの完全なエラー情報を取得できず、失敗したバッチのみをリトライすることはできません。したがって、両方のシステム変数がオンになっている場合は、非トランザクショナル DML ステートメントは冪等である必要があります。

## 使用例

### 非トランザクショナル DML ステートメントの使用

次のセクションでは、例を使用して非トランザクショナル DML ステートメントの使用方法について説明します：

次のスキーマでテーブル `t` を作成します：

{{< copyable "sql" >}}

```sql
CREATE TABLE t (id INT, v INT, KEY(id));
```

```sql
Query OK, 0 rows affected
```

テーブル `t` にいくつかのデータを挿入します。

{{< copyable "sql" >}}

```sql
INSERT INTO t VALUES (1, 2), (2, 3), (3, 4), (4, 5), (5, 6);
```

```sql
Query OK, 5 rows affected
```

以下の操作では、テーブル `t` の列 `v` の値が整数 6 未満の行を削除するために非トランザクショナル DML ステートメントを使用します。このステートメントは、2 つの SQL ステートメントに分割され、バッチサイズは 2 で、`id` 列でシャーディングされて実行されます。

{{< copyable "sql" >}}

```sql
BATCH ON id LIMIT 2 DELETE FROM t WHERE v < 6;
```

```sql
+----------------+---------------+
| number of jobs | job status    |
+----------------+---------------+
| 2              | all succeeded |
+----------------+---------------+
1 row in set
```

上記の非トランザクショナル DML ステートメントによる削除結果を確認します。

{{< copyable "sql" >}}

```sql
SELECT * FROM t;
```

```sql
+----+---+
| id | v |
+----+---+
| 5  | 6 |
+----+---+
1 row in set
```

次の例は、複数のテーブルを結合する方法について説明しています。まず、テーブル `t2` を作成し、データを挿入します：

```sql
CREATE TABLE t2(id int, v int, key(id));
INSERT INTO t2 VALUES (1,1), (3,3), (5,5);
```

次に、テーブル `t` および `t2` を結合してテーブル `t2` のデータを更新します。注意点として、シャード列をデータベース名、テーブル名、および列名 (`test.t.id`) と共に指定する必要があります：

```sql
BATCH ON test.t._tidb_rowid LIMIT 1 UPDATE t JOIN t2 ON t.id = t2.id SET t2.id = t2.id+1;
```

結果をクエリします：

```sql
SELECT * FROM t2;
```

```sql
+----+---+
| id | v |
+----+---+
| 1  | 1 |
| 3  | 3 |
| 6  | 5 |
+----+---+
```

### 実行の進捗を確認する

非トランザクションのDML文の実行中に、`SHOW PROCESSLIST`を使用して進捗状況を確認できます。返される結果の`Time`フィールドは、現在のバッチの実行にかかる時間を示します。ログとスローログには、非トランザクションのDML実行中の各スプリットステートメントの進捗も記録されます。例えば：

{{< copyable "sql" >}}

```sql
SHOW PROCESSLIST;
```

```sql
+------+------+--------------------+--------+---------+------+------------+----------------------------------------------------------------------------------------------------+
| Id   | User | Host               | db     | Command | Time | State      | Info                                                                                               |
+------+------+--------------------+--------+---------+------+------------+----------------------------------------------------------------------------------------------------+
| 1203 | root | 100.64.10.62:52711 | test   | Query   | 0    | autocommit | /* job 506/500000 */ DELETE FROM `test`.`t1` WHERE `test`.`t1`.`_tidb_rowid` BETWEEN 2271 AND 2273 |
| 1209 | root | 100.64.10.62:52735 | <null> | Query   | 0    | autocommit | show full processlist                                                                              |
+------+------+--------------------+--------+---------+------+------------+----------------------------------------------------------------------------------------------------+
```

### 非トランザクションのDML文を終了する

非トランザクションのDML文を終了するには、`KILL TIDB <processlist_id>`を使用できます。すると、TiDBは現在実行中のバッチ以降のすべてのバッチをキャンセルします。実行結果はログから取得できます。

`KILL TIDB`の詳細については、[`KILL`](/sql-statements/sql-statement-kill.md)のリファレンスを参照してください。

### バッチ分割ステートメントをクエリする

非トランザクションのDML文の実行中、内部的にはステートメントが使用されて、DML文を複数のバッチに分割します。バッチ分割ステートメントをクエリするには、この非トランザクションのDML文に`DRY RUN QUERY`を追加します。すると、TiDBはこのクエリとその後のDML操作は実行せず、バッチ分割ステートメントのみを返します。

次のステートメントは、`BATCH ON id LIMIT 2 DELETE FROM t WHERE v < 6`の実行中にバッチ分割ステートメントをクエリしています：

{{< copyable "sql" >}}

```sql
BATCH ON id LIMIT 2 DRY RUN QUERY DELETE FROM t WHERE v < 6;
```

```sql
+--------------------------------------------------------------------------------+
| query statement                                                                |
+--------------------------------------------------------------------------------+
| SELECT `id` FROM `test`.`t` WHERE (`v` < 6) ORDER BY IF(ISNULL(`id`),0,1),`id` |
+--------------------------------------------------------------------------------+
1 row in set
```

### 最初のバッチと最後のバッチに対応するステートメントをクエリする

非トランザクションのDML文の最初のバッチと最後のバッチに対応する実際のDMLステートメントをクエリするには、この非トランザクションのDML文に`DRY RUN`を追加します。すると、TiDBはバッチの分割ステートメントのみを実行し、これらのSQLステートメントは実行しません。バッチが多い場合、すべてのバッチが表示されず、最初のバッチと最後のバッチのみが表示されます。

{{< copyable "sql" >}}

```sql
BATCH ON id LIMIT 2 DRY RUN DELETE FROM t WHERE v < 6;
```

```sql
+-------------------------------------------------------------------+
| split statement examples                                          |
+-------------------------------------------------------------------+
| DELETE FROM `test`.`t` WHERE (`id` BETWEEN 1 AND 2 AND (`v` < 6)) |
| DELETE FROM `test`.`t` WHERE (`id` BETWEEN 3 AND 4 AND (`v` < 6)) |
+-------------------------------------------------------------------+
2 rows in set
```

### オプティマイザヒントの使用

非トランザクションの`DELETE`文で元々サポートされているオプティマイザヒントは、非トランザクションの`DELETE`文でもサポートされます。ヒントの位置は、通常の`DELETE`文と同じです：

{{< copyable "sql" >}}

```sql
BATCH ON id LIMIT 2 DELETE /*+ USE_INDEX(t)*/ FROM t WHERE v < 6;
```

## ベストプラクティス

非トランザクションのDML文を使用するには、以下の手順を推奨します。

1. 適切な[シャードカラム](#パラメータの説明)を選択します。整数型または文字列型を推奨します。
2. 非トランザクションのDML文に`DRY RUN QUERY`を追加し、クエリを手動で実行し、DML文によって影響を受けるデータ範囲がおおよそ正しいかどうかを確認します。
3. 非トランザクションのDML文に`DRY RUN`を追加し、クエリを手動で実行し、スプリットステートメントと実行計画を確認します。以下の点に注意してください：

    - スプリットステートメントが前のステートメントが書き込んだ結果を読み込むことがあるかどうか（これは異常を引き起こす可能性があります）。
    - インデックスの選択的な特性。
    - TiDBが自動的に選択したシャードカラムが変更されるかどうか。

4. 非トランザクションのDML文を実行します。
5. エラーが報告された場合は、エラーメッセージやログから具体的な失敗したデータ範囲を取得し、再試行または手動で処理します。

## パラメータの説明

| パラメータ | 説明 | デフォルト値 | 必須 | 推奨値 |
| :-- | :-- | :-- | :-- | :-- |
| シャードカラム | データをバッチ化するために使用するカラム。たとえば、上記の非トランザクションのDML文`BATCH ON id LIMIT 2 DELETE FROM t WHERE v < 6`中の`id`カラム。 | TiDBはシャードカラムを自動的に選択しようとします（推奨されません）。 | いいえ | 最も効率的に`WHERE`条件を満たすカラムを選択します。 |
| バッチサイズ | 各バッチのサイズを制御するために使用します。DML操作が分割されたSQLステートメントの数がバッチ数であり、上記の非トランザクションのDML文`BATCH ON id LIMIT 2 DELETE FROM t WHERE v < 6`中の`LIMIT 2`のようなものです。バッチが多いほど、バッチサイズが小さくなります。 | N/A | はい | 1000-1000000. バッチサイズが小さすぎるか大きすぎると、パフォーマンスが低下します。 |

### シャードカラムの選択方法

非トランザクションのDML文では、データのバッチ処理の基準となるカラムが必要となります。これがシャードカラムです。実行効率を向上させるためには、シャードカラムはインデックスを使用する必要があります。異なるインデックスとシャードカラムによっても、実行効率は数十倍以上異なる場合があります。シャードカラムを選ぶ際には、次の提案を考慮してください。

- アプリケーションのデータ分布を知っている場合、`WHERE`条件に基づいて、バッチ後にデータをより小さな範囲に分割するカラムを選択します。
    - 理想的には、`WHERE`条件がシャードカラムのインデックスを活用して、バッチごとのスキャンするデータ量を減らすことができます。例えば、各トランザクションの開始時刻と終了時刻を記録するトランザクションテーブルがあり、終了時刻が1か月前のトランザクションレコードをすべて削除する場合を考えます。トランザクションの開始時刻にインデックスがあり、トランザクションの開始時刻と終了時刻が比較的近い場合、開始時刻のカラムをシャードカラムとして選択できます。
    - 理想的ではない場合は、シャードカラムのデータ分布は`WHERE`条件とまったく独立しており、シャードカラムのインデックスを使用してデータスキャンの範囲を減らすことができません。
- クラスタ化インデックスが存在する場合は、主キー（`INT`主キーおよび`_tidb_rowid`を含む）をシャードカラムとして使用することをおすすめします。これにより、実行効率が向上します。
- 重複値の少ないカラムを選択してください。

シャードカラムを指定せずに選択できます。その場合、TiDBはデフォルトで`handle`の最初のカラムをシャードカラムとして使用します。ただし、クラスタ化インデックスの主キーの最初のカラムが非トランザクションのDML文でサポートされていないデータ型（`ENUM`、`BIT`、`SET`、`JSON`）である場合、TiDBはエラーを報告します。アプリケーションのニーズに応じて適切なシャードカラムを選択してください。

### バッチサイズの設定方法

非トランザクションのDML文では、バッチサイズが大きいほど、分割されるSQLステートメントが少なくなり、各SQLステートメントの実行が遅くなります。最適なバッチサイズはワークロードによって異なりますが、50000から開始することをおすすめします。バッチサイズが小さすぎるか大きすぎるいずれも実行効率の低下を引き起こします。

各バッチの情報はメモリに格納されるため、バッチが多すぎるとメモリ消費量が著しく増加します。これがバッチサイズが小さすぎる場合の説明です。非トランザクションの文によって情報が格納されるバッチ情報のメモリ使用の上限は、[`tidb_mem_quota_query`](/system-variables.md#tidb_mem_quota_query)と同じであり、これを超えた場合の動作は、設定項目[`tidb_mem_oom_action`](/system-variables.md#tidb_mem_oom_action-new-in-v610)で決まります。

## 制限事項

以下は、非トランザクションのDML文に対する厳しい制限事項です。これらの制限が満たされない場合、TiDBはエラーを報告します。

- DML文には`ORDER BY`または`LIMIT`句を含めることはできません。
- サブクエリや集合演算はサポートされていません。
- シャードカラムはインデックス化されている必要があります。インデックスは、単一カラムインデックスまたは複合インデックスの最初のカラムである必要があります。
- [`autocommit`](/system-variables.md#autocommit)モードで使用する必要があります。
- バッチ DML が有効な場合は使用できません。
- [`tidb_snapshot`](/read-historical-data.md#operation-flow) が設定されている場合は使用できません。
- `prepare` ステートメントとは併用できません。
- `ENUM`、`BIT`、`SET`、`JSON` タイプはシャードカラムとしてサポートされていません。
- [一時テーブル](/temporary-tables.md)ではサポートされていません。
- [共通表式](/develop/dev-guide-use-common-table-expression.md) はサポートされていません。

## バッチ実行の失敗を制御する

非トランザクショナル DML ステートメントは原子性を満たしません。一部のバッチが成功し、一部が失敗する可能性があります。システム変数 [`tidb_nontransactional_ignore_error`](/system-variables.md#tidb_nontransactional_ignore_error-new-in-v610) は、非トランザクショナル DML ステートメントがエラーを処理する方法を制御します。

例外として、最初のバッチが失敗した場合、ステートメント自体が間違っている可能性が高いです。この場合、非トランザクショナルステートメント全体は直接エラーを返します。

## 動作原理

非トランザクショナル DML ステートメントの動作原理は、SQL ステートメントの自動的な分割を TiDB に組み込むことにあります。非トランザクショナル DML ステートメントがない場合は、SQL ステートメントを手動で分割する必要があります。非トランザクショナル DML ステートメントの動作を理解するために、それを以下のようなタスクを実行するユーザースクリプトと考えてください。

非トランザクショナル DML `BATCH ON $C$ LIMIT $N$ DELETE FROM ... WHERE $P$` において、$C$ は分割に使用される列、$N$ はバッチサイズ、$P$ はフィルタ条件です。

1. 元のステートメントのフィルタ条件 $P$ および指定された列 $C$ に基づいて、TiDB は $P$ を満たすすべての $C$ をクエリします。TiDB はこれらの $C$ を $N$ に従って $B_1 \dots B_k$ のグループに整理します。すべての $B_i$ について、TiDB はその最初と最後の $C$ をそれぞれ $S_i$ と $E_i$ として保持します。このステップで実行されるクエリステートメントは [`DRY RUN QUERY`](/non-transactional-dml.md#query-the-batch-dividing-statement) で表示できます。
2. $B_i$ に含まれるデータは $P_i$: $C$ BETWEEN $S_i$ AND $E_i$ を満たす部分集合です。各バッチが処理するデータの範囲を $P_i$ で絞り込むことができます。
3. $B_i$ について、TiDB は元のステートメントの `WHERE` 条件に上記の条件を埋め込みます。これにより、WHERE ($P_i$) AND ($P$) となります。このステップの実行結果は [`DRY RUN`](/non-transactional-dml.md#query-the-statements-corresponding-to-the-first-and-the-last-batches) で表示できます。
4. すべてのバッチについて、新しいステートメントを順次実行します。各グループのエラーを収集し、組み合わせて、すべてのグループが完了した後に非トランザクショナル DML ステートメント全体の結果として返します。

## バッチ DML との比較

バッチ DML は、DML ステートメントの実行中に複数のトランザクションコミットにトランザクションを分割するメカニズムです。

> **注記:**
>
> 推奨されていないバッチ DML を使用することは避けてください。バッチ DML 機能が適切に使用されない場合、データインデックスの不整合のリスクがあります。

非トランザクショナル DML ステートメントはまだすべてのバッチ DML 使用シナリオの代替手段ではありません。主な違いは次のとおりです。

- パフォーマンス: [シャードカラム](#how-to-select-a-shard-column) が効率的な場合、非トランザクショナル DML ステートメントのパフォーマンスはバッチ DML に近くなります。シャードカラムが効率的でない場合、非トランザクショナル DML ステートメントのパフォーマンスはバッチ DML よりも大幅に低下します。

- 安定性: バッチ DML は不適切な使用により、データインデックスの不整合を起こしやすいです。非トランザクショナル DML ステートメントによってはデータインデックスの不整合は発生しません。ただし、不適切に使用すると、非トランザクショナル DML ステートメントは元のステートメントと等価ではなく、アプリケーションで予期しない挙動が観測されることがあります。詳細については [共通の問題のセクション](#non-transactional-delete-has-exceptional-behavior-that-is-not-equivalent-to-ordinary-delete) を参照してください。

## 共通の問題

### 実際のバッチサイズが指定されたバッチサイズと異なる場合

非トランザクショナル DML ステートメントの実行中、最後のバッチで処理されるデータのサイズは、指定されたバッチサイズよりも小さい場合があります。

**シャードカラムに重複する値が存在する場合**、各バッチにはそのバッチの最後の要素のシャードカラムのすべての重複する値が含まれます。したがって、このバッチの行数は指定されたバッチサイズよりも多くなる可能性があります。

また、他の同時書き込みが発生する場合、各バッチで処理される行数が指定されたバッチサイズと異なる場合があります。

### 実行中に `Failed to restore the delete statement, probably because of unsupported type of the shard column` エラーが発生する

シャードカラムが `ENUM`、`BIT`、`SET`、`JSON` タイプをサポートしていません。新しいシャードカラムを指定してみてください。整数型または文字列型のカラムを使用することをお勧めします。

<CustomContent platform="tidb">

選択されたシャードカラムがこれらの未サポートのタイプのいずれでない場合、PingCAP またはコミュニティから [サポートを受ける](/support.md) ことができます。

</CustomContent>

<CustomContent platform="tidb-cloud">

選択されたシャードカラムがこれらの未サポートのタイプのいずれでない場合、[TiDB Cloud サポートに連絡](/tidb-cloud/tidb-cloud-support.md) してください。

</CustomContent>

### 非トランザクショナル `DELETE` は通常の `DELETE` とは等価でない「特異な」動作をします

非トランザクショナル DML ステートメントは、元の DML ステートメントの形式と等価ではなくなることがあります。これには以下のような理由があります。

- 他の同時書き込みが存在する。
- 非トランザクショナル DML ステートメントがステートメント自体が読み取る値を修正します。
- 各バッチで実行される SQL ステートメントが `WHERE` 条件が変更されるため、異なる実行計画や式の計算順序を引き起こすことがあります。そのため、実行結果が元のステートメントと異なる可能性があります。
- DML ステートメントには非決定的な操作が含まれています。

## MySQL 互換性

非トランザクショナルステートメントは TiDB 固有のものであり、MySQL とは互換性がありません。

## 関連情報

* [`BATCH`](/sql-statements/sql-statement-batch.md) 構文
* [`tidb_nontransactional_ignore_error`](/system-variables.md#tidb_nontransactional_ignore_error-new-in-v610)